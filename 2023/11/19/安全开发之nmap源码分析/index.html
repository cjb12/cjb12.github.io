<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        Hexo
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            安全开发之nmap源码分析
        </p>
        <hr>
    </div>
    <div class="post-content">
        <p>因为想自己写一点安全工具，所以先看看一些优秀的安全工具的源码，故有此文</p>
<p>（本文旨在浏览关键代码，并无深究其中代码细节</p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/13023">https://xz.aliyun.com/t/13023</a></p>
<h2 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h2><p>源码下载：<a target="_blank" rel="noopener" href="https://nmap.org/dist/nmap-7.94.tgz%EF%BC%8C%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%EF%BC%9A2023-05-20">https://nmap.org/dist/nmap-7.94.tgz，更新时间：2023-05-20</a></p>
<p>下载源码后先看目录结构，在源码处使用cmd命令：tree，列出目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">├─.github</span><br><span class="line">│  └─ISSUE_TEMPLATE      //该目录包含了用于创建GitHub问题（issues）时的模板文件。模板文件定义了问题报告或建议的结构和                                格式，以帮助用户提供有用的反馈信息。</span><br><span class="line">├─docs                   //相关文档   </span><br><span class="line">│  ├─licenses</span><br><span class="line">│  ├─man-xlate</span><br><span class="line">│  └─style</span><br><span class="line">├─libdnet-stripped       //libdnet:网络接口开源库</span><br><span class="line">│  ├─config</span><br><span class="line">│  ├─include</span><br><span class="line">│  │  └─dnet</span><br><span class="line">│  └─src</span><br><span class="line">├─liblinear              //liblinear:大型线性分类开源库   </span><br><span class="line">│  └─blas</span><br><span class="line">├─liblua                 //Lua脚本语言源码</span><br><span class="line">├─libnetutil             //nmap网络实用函数</span><br><span class="line">├─libpcap                //libpcap:开源抓包库</span><br><span class="line">│  ├─bpf</span><br><span class="line">│  │  └─net</span><br><span class="line">│  ├─ChmodBPF</span><br><span class="line">│  ├─cmake</span><br><span class="line">│  │  └─Modules</span><br><span class="line">│  ├─config</span><br><span class="line">│  ├─lbl</span><br><span class="line">│  ├─missing</span><br><span class="line">│  ├─msdos</span><br><span class="line">│  ├─NMAP_MODIFICATIONS</span><br><span class="line">│  ├─packaging</span><br><span class="line">│  ├─pcap</span><br><span class="line">│  ├─SUNOS4</span><br><span class="line">│  ├─testprogs</span><br><span class="line">│  ├─tests</span><br><span class="line">│  └─Win32</span><br><span class="line">│      ├─Include</span><br><span class="line">│      │  ├─arpa</span><br><span class="line">│      │  └─net</span><br><span class="line">│      ├─Prj</span><br><span class="line">│      └─Src</span><br><span class="line">├─libpcre                //libpcre:处理正则匹配的开源库</span><br><span class="line">├─libssh2                //libssh2:实现ssh协议的开源库</span><br><span class="line">│  ├─cmake</span><br><span class="line">│  ├─include</span><br><span class="line">│  ├─m4</span><br><span class="line">│  ├─nw</span><br><span class="line">│  │  └─test</span><br><span class="line">│  ├─os400</span><br><span class="line">│  │  ├─include</span><br><span class="line">│  │  │  └─sys</span><br><span class="line">│  │  └─libssh2rpg</span><br><span class="line">│  ├─src</span><br><span class="line">│  ├─vms</span><br><span class="line">│  └─win32</span><br><span class="line">│      └─test</span><br><span class="line">├─libz                   //libz:用于数据压缩和解压缩的开源库</span><br><span class="line">│  ├─amiga</span><br><span class="line">│  ├─contrib</span><br><span class="line">│  │  ├─ada</span><br><span class="line">│  │  ├─amd64</span><br><span class="line">│  │  ├─asm686</span><br><span class="line">│  │  ├─blast</span><br><span class="line">│  │  ├─delphi</span><br><span class="line">│  │  ├─dotzlib</span><br><span class="line">│  │  │  └─DotZLib</span><br><span class="line">│  │  ├─gcc_gvmat64</span><br><span class="line">│  │  ├─infback9</span><br><span class="line">│  │  ├─inflate86</span><br><span class="line">│  │  ├─iostream</span><br><span class="line">│  │  ├─iostream2</span><br><span class="line">│  │  ├─iostream3</span><br><span class="line">│  │  ├─masmx64</span><br><span class="line">│  │  ├─masmx86</span><br><span class="line">│  │  ├─minizip</span><br><span class="line">│  │  ├─pascal</span><br><span class="line">│  │  ├─puff</span><br><span class="line">│  │  ├─testzlib</span><br><span class="line">│  │  ├─untgz</span><br><span class="line">│  │  └─vstudio</span><br><span class="line">│  │      ├─vc10</span><br><span class="line">│  │      ├─vc11</span><br><span class="line">│  │      ├─vc12</span><br><span class="line">│  │      ├─vc14</span><br><span class="line">│  │      └─vc9</span><br><span class="line">│  ├─doc</span><br><span class="line">│  ├─examples</span><br><span class="line">│  ├─msdos</span><br><span class="line">│  ├─nintendods</span><br><span class="line">│  ├─old</span><br><span class="line">│  │  └─os2</span><br><span class="line">│  ├─os400</span><br><span class="line">│  ├─qnx</span><br><span class="line">│  ├─test</span><br><span class="line">│  ├─watcom</span><br><span class="line">│  └─win32</span><br><span class="line">├─macosx                     //支持苹果操作系统</span><br><span class="line">│  └─nmap.pmdoc</span><br><span class="line">├─mswin32                    //支持Windows操作系统</span><br><span class="line">│  ├─license-format</span><br><span class="line">│  ├─NET</span><br><span class="line">│  ├─NETINET</span><br><span class="line">│  ├─nsis</span><br><span class="line">│  └─RPC</span><br><span class="line">├─nbase                      //nmap封装的基础使用程序库</span><br><span class="line">│  └─test</span><br><span class="line">├─ncat                       //nmap项目组实现的新版nc</span><br><span class="line">│  ├─certs</span><br><span class="line">│  ├─docs</span><br><span class="line">│  │  └─examples</span><br><span class="line">│  │      ├─logs</span><br><span class="line">│  │      └─scripts</span><br><span class="line">│  │          └─http-scan</span><br><span class="line">│  ├─scripts</span><br><span class="line">│  │  └─filters</span><br><span class="line">│  └─test</span><br><span class="line">│      └─test-env-w32</span><br><span class="line">├─ndiff                      //比较扫描结果</span><br><span class="line">│  ├─docs</span><br><span class="line">│  ├─scripts</span><br><span class="line">│  └─test-scans</span><br><span class="line">├─nping                      //网络探测与构建packet</span><br><span class="line">│  └─docs</span><br><span class="line">├─nselib                     //Lua语言编写的常用的脚本库</span><br><span class="line">│  └─data</span><br><span class="line">│      ├─jdwp-class</span><br><span class="line">│      └─psexec</span><br><span class="line">├─nsock                      //并行的SocketEvent处理库</span><br><span class="line">│  ├─include</span><br><span class="line">│  ├─src</span><br><span class="line">│  └─tests</span><br><span class="line">├─scripts                    //常用的扫描检查的lua脚本</span><br><span class="line">├─tests                      //使用了Nmap Security Scanner项目中的DNS模块，目的是验证该模块在解析DNS数据包时的正确性</span><br><span class="line">├─todo                       //介绍Nmap项目将来开发的具体任务</span><br><span class="line">└─zenmap                     //python编写的图形界面</span><br><span class="line">    ├─install_scripts</span><br><span class="line">    │  ├─macosx</span><br><span class="line">    │  ├─unix</span><br><span class="line">    │  ├─utils</span><br><span class="line">    │  └─windows</span><br><span class="line">    ├─radialnet</span><br><span class="line">    │  ├─bestwidgets</span><br><span class="line">    │  ├─core</span><br><span class="line">    │  ├─gui</span><br><span class="line">    │  ├─share</span><br><span class="line">    │  │  └─sample</span><br><span class="line">    │  └─util</span><br><span class="line">    ├─share</span><br><span class="line">    │  └─zenmap</span><br><span class="line">    │      ├─config</span><br><span class="line">    │      ├─docs</span><br><span class="line">    │      ├─locale</span><br><span class="line">    │      │  ├─de</span><br><span class="line">    │      │  │  └─LC_MESSAGES</span><br><span class="line">    │      │  ├─es</span><br><span class="line">    │      │  │  └─LC_MESSAGES</span><br><span class="line">    │      │  ├─fr</span><br><span class="line">    │      │  │  └─LC_MESSAGES</span><br><span class="line">    │      │  ├─hi</span><br><span class="line">    │      │  │  └─LC_MESSAGES</span><br><span class="line">    │      │  ├─hr</span><br><span class="line">    │      │  │  └─LC_MESSAGES</span><br><span class="line">    │      │  ├─it</span><br><span class="line">    │      │  │  └─LC_MESSAGES</span><br><span class="line">    │      │  ├─ja</span><br><span class="line">    │      │  │  └─LC_MESSAGES</span><br><span class="line">    │      │  ├─pl</span><br><span class="line">    │      │  │  └─LC_MESSAGES</span><br><span class="line">    │      │  ├─pt_BR</span><br><span class="line">    │      │  │  └─LC_MESSAGES</span><br><span class="line">    │      │  ├─ru</span><br><span class="line">    │      │  │  └─LC_MESSAGES</span><br><span class="line">    │      │  └─zh</span><br><span class="line">    │      │      └─LC_MESSAGES</span><br><span class="line">    │      ├─misc</span><br><span class="line">    │      └─pixmaps</span><br><span class="line">    │          └─radialnet</span><br><span class="line">    ├─test</span><br><span class="line">    ├─zenmapCore</span><br><span class="line">    └─zenmapGUI</span><br><span class="line">        └─higwidgets</span><br></pre></td></tr></table></figure>



<p><strong>执行流程</strong></p>
<p>主要工作在：nmap.cc<br>可以看到，此实现的是一些端口扫描功能以及命令行用户界面，main函数在main.cc中</p>
<p>接着看main.cc<br>可以看到，这个文件除了调用nmap_main()（位于nmap.cc中）之外，几乎不执行任何操作</p>
<p>再返回来看nmap.cc的nmap_main()函数<br>Nmap的所有的功能都在此nmap_main()设有入口，以此为基础可以更深入地分析Nmap的其他模块<br>下面是详细的代码分析：</p>
<p>开始是定义一些变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nmap_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt; Targets;</span><br><span class="line">  <span class="type">time_t</span> now;</span><br><span class="line">  <span class="type">time_t</span> timep;</span><br><span class="line">  <span class="type">char</span> mytime[<span class="number">128</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">addrset</span> *<span class="title">exclude_group</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NOLUA</span></span><br><span class="line">  <span class="comment">/* 扫描前和扫描后脚本结果数据结构 */</span> </span><br><span class="line">  ScriptResults *script_scan_results = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ideal_scan_group_sz = <span class="number">0</span>;</span><br><span class="line">  Target *currenths;</span><br><span class="line">  <span class="type">char</span> myname[FQDN_LEN + <span class="number">1</span>];</span><br><span class="line">  <span class="type">int</span> sourceaddrwarning = <span class="number">0</span>; <span class="comment">/* 我们有没有警告过他们不可访问的源地址？ */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> targetno;</span><br><span class="line">  <span class="type">char</span> hostname[FQDN_LEN + <span class="number">1</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span></span><br><span class="line">  <span class="type">size_t</span> sslen;</span><br><span class="line">  <span class="type">int</span> err;</span><br></pre></td></tr></table></figure>

<p>然后是一个预处理，用于条件编译</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LINUX</span></span><br><span class="line">  <span class="comment">/* 检查WSL，并警告事情可能进展不顺利。 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> <span class="title">uts</span>;</span>      <span class="comment">//存储系统信息              </span></span><br><span class="line">  <span class="keyword">if</span> (!uname(&amp;uts)) &#123;      <span class="comment">//打印警告信息，提示用户当前运行的程序（NMAP_NAME）可能在Windows Subsystem for Linux上无法正                              常工作，并建议使用原生的Windows版本，提供了下载链接（NMAP_URL）。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(uts.release, <span class="string">&quot;Microsoft&quot;</span>) != <span class="literal">NULL</span>) &#123; </span><br><span class="line">      error(<span class="string">&quot;Warning: %s may not work correctly on Windows Subsystem for Linux.\n&quot;</span></span><br><span class="line">          <span class="string">&quot;For best performance and accuracy, use the native Windows build from %s/download.html#windows.&quot;</span>,</span><br><span class="line">          NMAP_NAME, NMAP_URL);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>继续</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tzset();     </span><br><span class="line">now = time(<span class="literal">NULL</span>);</span><br><span class="line">err = n_localtime(&amp;now, &amp;local_time);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">  fatal(<span class="string">&quot;n_localtime failed: %s&quot;</span>, strerror(err));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码是涉及时间的相关操作，会将当前时区时间与系统时间进行比对</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">  printusage();</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Targets.reserve(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>这里的argc是运行时传入的参数，如果小于2个，调用<code>printusage()</code>，这个函数是列举nmap的功能<br>下面的Targets是一个<code>std::vector</code>对象，<code>std::vector</code>是C++标准库中的一个容器类，它可以存储一系列的元素，并提供了方便的方法来访问和操作这些元素。这里为<code>Targets</code>容器预留了100个元素的内存空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">  win_pre_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在Windows操作系统上启动Winsock库，并检查启动过程中是否出现错误</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">parse_options(argc, argv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (o.debugging)</span><br><span class="line">  nbase_set_log(fatal, error);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  nbase_set_log(fatal, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tty_init(); <span class="comment">// 将键盘置于原始模式</span></span><br></pre></td></tr></table></figure>

<p><code>parse_options()</code>函数用于解析命令行参数，然后的判断是是否启用调试模式，写入日志。<br><code>tty_init()</code>函数用于初始化终端，包括打开终端设备、设置终端属性和注册清理函数等。它会根据配置和环境的不同采取不同的处理逻辑，以确保终端的正确初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">  <span class="comment">// Must come after parse_options because of --unprivileged</span></span><br><span class="line">  <span class="comment">// Must come before apply_delayed_options because it sets o.isr00t</span></span><br><span class="line">  win_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>win_init()</code>函数调用WSAStartup启动Winsock DLL，后续网络解析等需要用到。  </p>
<p>然后是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply_delayed_options();</span><br></pre></td></tr></table></figure>

<p>此函数的功能是将解析命令时需要延迟执行的操作在此处处理，先不深究</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; route_dst_hosts.size(); i++) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *dst;             <span class="comment">//用于存储目标地址</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span>  <span class="comment">//用于存储解析后的目标地址信息</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">route_nfo</span> <span class="title">rnfo</span>;</span>       <span class="comment">//用于存储路由信息</span></span><br><span class="line">  <span class="type">size_t</span> sslen;                <span class="comment">//用于存储目标地址信息的长度</span></span><br><span class="line">  <span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">  dst = route_dst_hosts[i].c_str();   <span class="comment">//将route_dst_hosts容器中的第i个元素转换为C风格的字符串，并将其赋值给dst变量</span></span><br><span class="line">  rc = resolve(dst, <span class="number">0</span>, &amp;ss, &amp;sslen, o.af());  <span class="comment">//将目标地址dst解析为网络地址，并将解析结果存储在ss和sslen中</span></span><br><span class="line">  <span class="keyword">if</span> (rc != <span class="number">0</span>)    <span class="comment">//如果解析失败，打印错误信息并终止程序执行</span></span><br><span class="line">    fatal(<span class="string">&quot;Can&#x27;t resolve %s: %s.&quot;</span>, dst, gai_strerror(rc));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, inet_ntop_ez(&amp;ss, sslen));  <span class="comment">//打印解析后的目标地址，使用inet_ntop_ez()函数将二进制地址转换为可打印的字符串形式</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!route_dst(&amp;ss, &amp;rnfo, o.device, o.SourceSockAddr())) &#123; <span class="comment">//调用route_dst()函数，根据目标地址ss、网络设备o.device和源地址o.SourceSockAddr()获取路由信息，并进行条件判断。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t route %s (%s).&quot;</span>, dst, inet_ntop_ez(&amp;ss, sslen));  <span class="comment">//如果无法获取路由信息，打印错误信息</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %s&quot;</span>, rnfo.ii.devname, rnfo.ii.devfullname);   <span class="comment">//打印路由信息中的设备名称和设备全名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; srcaddr %s&quot;</span>, inet_ntop_ez(&amp;rnfo.srcaddr, <span class="keyword">sizeof</span>(rnfo.srcaddr)));  <span class="comment">//打印路由信息中的源地址</span></span><br><span class="line">    <span class="keyword">if</span> (rnfo.direct_connect)  <span class="comment">//如果路由信息中存在直接连接（direct connect），打印相应的提示信息</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot; direct&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot; nexthop %s&quot;</span>, inet_ntop_ez(&amp;rnfo.nexthop, <span class="keyword">sizeof</span>(rnfo.nexthop)));  <span class="comment">//如果路由信息中存在下一跳地址，打印相应的提示信息。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">route_dst_hosts.clear();   <span class="comment">//清空route_dst_hosts容器，删除其中的所有元素。</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>route_dst_hosts</code>来自<code>static std::vector&lt;std::string&gt; route_dst_hosts;</code>，也是一个容器。存放的内容可以是ip，也可以是域名。<br>这段代码的目的是遍历<code>route_dst_hosts</code>容器中的目标地址，进行解析、路由查询和打印相应的信息。最后，清空容器，准备处理下一批目标地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (delayed_options.iflist) &#123;</span><br><span class="line">    print_iflist();  <span class="comment">//用于打印接口列表的信息</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>跟踪到<code>delayed_options.iflist</code>的地方</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">o.scanflags = parse_scanflags(optarg);</span><br><span class="line"><span class="keyword">if</span> (o.scanflags &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            fatal(<span class="string">&quot;--scanflags option must be a number between 0 and 255 (inclusive) or a string like \&quot;URGPSHFIN\&quot;.&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(long_options[option_index].name, <span class="string">&quot;iflist&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">          delayed_options.iflist = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>第一行的<code>parse_scanflags()</code>函数是判断端口是否在0-255，第二行的<code>fatal</code>是封装的输出函数。这里会输出一个字符串。<br>再往下就是判断是否传入 “iflist” 参数。结合上面一段代码，所以就是进行参数的判断，如果有，则打印接口列表的信息</p>
<p>​	</p>
<p>继续看nmap.cc的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果他想跳出FTP站点，那个站点最好是可以访问的！ */</span></span><br><span class="line"><span class="keyword">if</span> (o.bouncescan) &#123;     <span class="comment">//是否启用了 FTP 弹跳扫描</span></span><br><span class="line">  <span class="type">int</span> rc = resolve(ftp.server_name, <span class="number">0</span>, &amp;ss, &amp;sslen, AF_INET);<span class="comment">//调用resolve()函数来解析 FTP 弹跳代理主机名或 IP 地址</span></span><br><span class="line">  <span class="keyword">if</span> (rc != <span class="number">0</span>)  <span class="comment">//检查解析是否成功</span></span><br><span class="line">      fatal(<span class="string">&quot;Failed to resolve FTP bounce proxy hostname/IP: %s&quot;</span>,</span><br><span class="line">            ftp.server_name);</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;ftp.server, &amp;((sockaddr_in *)&amp;ss)-&gt;sin_addr, <span class="number">4</span>);  <span class="comment">//将解析得到的 IP 地址复制到 ftp.server 变量中</span></span><br><span class="line">  <span class="keyword">if</span> (o.verbose) &#123;  <span class="comment">//检查是否启用了详细输出模式</span></span><br><span class="line">    log_write(LOG_STDOUT, <span class="string">&quot;Resolved FTP bounce attack proxy to %s (%s).\n&quot;</span>,</span><br><span class="line">              ftp.server_name, inet_ntoa(ftp.server)); </span><br><span class="line">      <span class="comment">//使用 log_write() 函数将解析得到的 FTP 弹跳代理的主机名和 IP 地址输出到标准输出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fflush(<span class="built_in">stdout</span>);   <span class="comment">//刷新标准输出缓冲区，确保输出被立即写入</span></span><br><span class="line">fflush(<span class="built_in">stderr</span>);   <span class="comment">//刷新标准错误输出缓冲区，确保错误消息被立即写入</span></span><br></pre></td></tr></table></figure>

<p>这一段涉及到一个知识点：FTP弹跳扫描<br>FTP 协议有一个特点是支持代理 ftp 连接。利用了FTP服务器上的”PORT”命令和”EPRT”命令的特性。代理连接指的是它允许用户连接到一台 FTP 服务器，然后要求此 FTP 服务器将文件送到一台第三方服务器。所以导致 FTP 服务器可以利用于对其它主机端口扫描。</p>
<p>这段代码片段的目的是解析 FTP 弹跳代理的主机名或 IP 地址，并将解析结果存储在 <code>ftp.server</code> 变量中，为扫描做准备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">timep = time(<span class="literal">NULL</span>);</span><br><span class="line">err = n_ctime(mytime, <span class="keyword">sizeof</span>(mytime), &amp;timep);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">  fatal(<span class="string">&quot;n_ctime failed: %s&quot;</span>, strerror(err));</span><br><span class="line">&#125;</span><br><span class="line">chomp(mytime);</span><br></pre></td></tr></table></figure>

<p>和前面的一段类似，这里多了个<code>chomp()</code>函数，他的作用是去除 <code>mytime</code> 字符串末尾的换行符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!o.resuming) &#123;    <span class="comment">//检查是否需要生成 XML 输出</span></span><br><span class="line">  <span class="comment">/* 简要信息以防他们忘记扫描的内容 */</span></span><br><span class="line">  <span class="type">char</span> *xslfname = o.XSLStyleSheet();  <span class="comment">//获取 XSL 样式表文件名，并将结果保存在 xslfname 变量中</span></span><br><span class="line">  xml_start_document(<span class="string">&quot;nmaprun&quot;</span>);       <span class="comment">//开始一个名为 &quot;nmaprun&quot; 的 XML 文档</span></span><br><span class="line">  <span class="keyword">if</span> (xslfname) &#123;                      <span class="comment">//是否存在 XSL 样式表文件</span></span><br><span class="line">    xml_open_pi(<span class="string">&quot;xml-stylesheet&quot;</span>);     <span class="comment">//打开一个 XML 处理指令</span></span><br><span class="line">    xml_attribute(<span class="string">&quot;href&quot;</span>, <span class="string">&quot;%s&quot;</span>, xslfname); <span class="comment">//添加一个名为 &quot;href&quot; 的属性，其值为 xslfname 变量的内容</span></span><br><span class="line">    xml_attribute(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;text/xsl&quot;</span>);     <span class="comment">//添加一个名为 &quot;type&quot; 的属性，其值为 &quot;text/xsl&quot;</span></span><br><span class="line">    xml_close_pi();                        <span class="comment">//关闭 XML 处理指令</span></span><br><span class="line">    xml_newline();                         <span class="comment">//在 XML 文档中插入一个换行符</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  xml_start_comment();          <span class="comment">//开始一个注释块</span></span><br><span class="line">  xml_write_escaped(<span class="string">&quot; %s %s scan initiated %s as: %s &quot;</span>, NMAP_NAME, NMAP_VERSION, mytime, join_quoted(argv, argc).c_str());                   <span class="comment">//在注释块中输出一段包含程序名称、版本号、扫描启动时间和命令行参数的信息</span></span><br><span class="line">  xml_end_comment();            <span class="comment">//结束注释块</span></span><br><span class="line">  xml_newline();</span><br><span class="line"></span><br><span class="line">  xml_open_start_tag(<span class="string">&quot;nmaprun&quot;</span>);     <span class="comment">//打开一个名为 &quot;nmaprun&quot; 的 XML 元素</span></span><br><span class="line">  xml_attribute(<span class="string">&quot;scanner&quot;</span>, <span class="string">&quot;nmap&quot;</span>);  <span class="comment">//和上面类似，添加属性</span></span><br><span class="line">  xml_attribute(<span class="string">&quot;args&quot;</span>, <span class="string">&quot;%s&quot;</span>, join_quoted(argv, argc).c_str());</span><br><span class="line">  xml_attribute(<span class="string">&quot;start&quot;</span>, <span class="string">&quot;%lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>) timep);</span><br><span class="line">  xml_attribute(<span class="string">&quot;startstr&quot;</span>, <span class="string">&quot;%s&quot;</span>, mytime);</span><br><span class="line">  xml_attribute(<span class="string">&quot;version&quot;</span>, <span class="string">&quot;%s&quot;</span>, NMAP_VERSION);</span><br><span class="line">  xml_attribute(<span class="string">&quot;xmloutputversion&quot;</span>, NMAP_XMLOUTPUTVERSION);</span><br><span class="line">  xml_close_start_tag();    <span class="comment">//关闭 XML 元素的开始标签。</span></span><br><span class="line">  xml_newline();</span><br><span class="line"></span><br><span class="line">  output_xml_scaninfo_records(&amp;ports);  <span class="comment">//输出扫描信息记录到 XML 文档中</span></span><br><span class="line"></span><br><span class="line">  xml_open_start_tag(<span class="string">&quot;verbose&quot;</span>);</span><br><span class="line">  xml_attribute(<span class="string">&quot;level&quot;</span>, <span class="string">&quot;%d&quot;</span>, o.verbose);</span><br><span class="line">  xml_close_empty_tag();</span><br><span class="line">  xml_newline();</span><br><span class="line">  xml_open_start_tag(<span class="string">&quot;debugging&quot;</span>);</span><br><span class="line">  xml_attribute(<span class="string">&quot;level&quot;</span>, <span class="string">&quot;%d&quot;</span>, o.debugging);</span><br><span class="line">  xml_close_empty_tag();</span><br><span class="line">  xml_newline();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  xml_start_tag(<span class="string">&quot;nmaprun&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码的作用是根据条件判断是否需要生成 XML 输出，会生成包含扫描信息的 XML 文档</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_write(LOG_NORMAL | LOG_MACHINE, <span class="string">&quot;# &quot;</span>);</span><br><span class="line">log_write(LOG_NORMAL | LOG_MACHINE, <span class="string">&quot;%s %s scan initiated %s as: %s&quot;</span>, NMAP_NAME, NMAP_VERSION, mytime, join_quoted(argv, argc).c_str());</span><br><span class="line">log_write(LOG_NORMAL | LOG_MACHINE, <span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这三句都是进行日志操作，将一些扫描相关的信息以特定格式记录到日志中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* 在我们随机化扫描的端口之前，让我们将它们输出到机器可解析的输出中 */</span></span><br><span class="line">  <span class="keyword">if</span> (o.verbose)   <span class="comment">//检查是否设置了详细输出的标志</span></span><br><span class="line">    output_ports_to_machine_parseable_output(&amp;ports); <span class="comment">//将扫描的端口信息输出为机器可解析的格式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(HAVE_SIGNAL) &amp;&amp; defined(SIGPIPE)</span></span><br><span class="line">  signal(SIGPIPE, SIG_IGN); <span class="comment">/* 忽略 SIGPIPE，这样我们的程序就不会因此而崩溃，但我们真的不应该收到意外的 SIGPIPE */</span></span><br><span class="line">                            <span class="comment">//通过将其处理方式设置为忽略，可以防止程序因为 SIGPIPE 而崩溃</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>知识点：SIGPIPE 信号是在Unix和类Unix系统中的一种信号，它表示管道破裂，当一个进程试图向一个已经关闭写端的管道写数据时，内核会向该进程发送SIGPIPE信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o.max_parallelism &amp;&amp; (i = max_sd()) &amp;&amp; i &lt; o.max_parallelism) &#123;</span><br><span class="line">  error(<span class="string">&quot;WARNING: Your specified max_parallel_sockets of %d, but your system says it might only give us %d.  Trying anyway&quot;</span>, o.max_parallelism, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (o.debugging &gt; <span class="number">1</span>)</span><br><span class="line">  log_write(LOG_STDOUT, <span class="string">&quot;The max # of sockets we are using is: %d\n&quot;</span>, o.max_parallelism);</span><br></pre></td></tr></table></figure>

<p>在进行并行扫描之前，检查最大并行套接字数的限制和系统实际可提供的最大套接字描述符数之间的关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时，我们应该充分了解我们的时间参数</span></span><br><span class="line"><span class="keyword">if</span> (o.debugging) &#123;</span><br><span class="line">  log_write(LOG_PLAIN, <span class="string">&quot;--------------- Timing report ---------------\n&quot;</span>);</span><br><span class="line">  log_write(LOG_PLAIN, <span class="string">&quot;  hostgroups: min %d, max %d\n&quot;</span>, o.minHostGroupSz(), o.maxHostGroupSz());</span><br><span class="line">  log_write(LOG_PLAIN, <span class="string">&quot;  rtt-timeouts: init %d, min %d, max %d\n&quot;</span>, o.initialRttTimeout(), o.minRttTimeout(), o.maxRttTimeout());</span><br><span class="line">  log_write(LOG_PLAIN, <span class="string">&quot;  max-scan-delay: TCP %d, UDP %d, SCTP %d\n&quot;</span>, o.maxTCPScanDelay(), o.maxUDPScanDelay(), o.maxSCTPScanDelay());</span><br><span class="line">  log_write(LOG_PLAIN, <span class="string">&quot;  parallelism: min %d, max %d\n&quot;</span>, o.min_parallelism, o.max_parallelism);</span><br><span class="line">  log_write(LOG_PLAIN, <span class="string">&quot;  max-retries: %d, host-timeout: %ld\n&quot;</span>, o.getMaxRetransmissions(), o.host_timeout);</span><br><span class="line">  log_write(LOG_PLAIN, <span class="string">&quot;  min-rate: %g, max-rate: %g\n&quot;</span>, o.min_packet_send_rate, o.max_packet_send_rate);</span><br><span class="line">  log_write(LOG_PLAIN, <span class="string">&quot;---------------------------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调试模式下，输出一个时间报告到日志</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在随机化扫描的端口之前，我们必须初始化PortList类。 */</span></span><br><span class="line"><span class="keyword">if</span> (o.ipprotscan)    <span class="comment">//是否启用了 IP 协议扫描</span></span><br><span class="line">  PortList::initializePortMap(IPPROTO_IP,  ports.prots, ports.prot_count); <span class="comment">//初始化 IP 协议的端口映射</span></span><br><span class="line"><span class="keyword">if</span> (o.TCPScan())     <span class="comment">//是否启用了 TCP 扫描</span></span><br><span class="line">  PortList::initializePortMap(IPPROTO_TCP, ports.tcp_ports, ports.tcp_count); <span class="comment">//初始化 TCP 协议的端口映射</span></span><br><span class="line"><span class="keyword">if</span> (o.UDPScan())     <span class="comment">//是否启用了 UDP 扫描</span></span><br><span class="line">  PortList::initializePortMap(IPPROTO_UDP, ports.udp_ports, ports.udp_count);  <span class="comment">//初始化 UDP 协议的端口映射</span></span><br><span class="line"><span class="keyword">if</span> (o.SCTPScan())    <span class="comment">//启用了 SCTP 扫描</span></span><br><span class="line">  PortList::initializePortMap(IPPROTO_SCTP, ports.sctp_ports, ports.sctp_count); <span class="comment">//初始化 SCTP 协议的端口映射</span></span><br></pre></td></tr></table></figure>

<p>在进行随机化扫描之前，根据不同的协议类型初始化对应的端口映射</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o.randomize_ports) &#123;      <span class="comment">//是否启用了随机化端口扫描</span></span><br><span class="line">  <span class="keyword">if</span> (ports.tcp_count) &#123;      <span class="comment">//检查 TCP 端口数量是否大于零</span></span><br><span class="line">    shortfry(ports.tcp_ports, ports.tcp_count);   <span class="comment">//对 TCP 端口数组进行随机化操作</span></span><br><span class="line">    <span class="comment">// 将一些更常见的端口移到更靠近开始的位置，以加快扫描速度</span></span><br><span class="line">    random_port_cheat(ports.tcp_ports, ports.tcp_count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ports.udp_count)   <span class="comment">//检查 UDP 端口数量是否大于零</span></span><br><span class="line">    shortfry(ports.udp_ports, ports.udp_count);     <span class="comment">//端口随机化操作</span></span><br><span class="line">  <span class="keyword">if</span> (ports.sctp_count)  <span class="comment">//检查 SCTP 端口数量</span></span><br><span class="line">    shortfry(ports.sctp_ports, ports.sctp_count);</span><br><span class="line">  <span class="keyword">if</span> (ports.prot_count)  <span class="comment">//检查协议端口数量</span></span><br><span class="line">    shortfry(ports.prots, ports.prot_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在需要随机化端口时，对不同协议类型的端口数组进行随机化操作</p>
<p>将<code>random_port_cheat()</code>函数的具体实现方法拿过来，写一段代码测试此函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> __int16 <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> u16;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">random_port_cheat</span><span class="params">(u16* ports, <span class="type">int</span> portcount)</span> &#123;</span><br><span class="line">    <span class="type">int</span> allportidx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> popportidx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> earlyreplidx = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Updated 2008-12-19 from nmap-services-all.</span></span><br><span class="line"><span class="comment">       Top 25 open TCP ports plus 113, 554, and 256 */</span></span><br><span class="line">    u16 pop_ports[] = &#123;</span><br><span class="line">      <span class="number">80</span>, <span class="number">23</span>, <span class="number">443</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">25</span>, <span class="number">3389</span>, <span class="number">110</span>, <span class="number">445</span>, <span class="number">139</span>,</span><br><span class="line">      <span class="number">143</span>, <span class="number">53</span>, <span class="number">135</span>, <span class="number">3306</span>, <span class="number">8080</span>, <span class="number">1723</span>, <span class="number">111</span>, <span class="number">995</span>, <span class="number">993</span>, <span class="number">5900</span>,</span><br><span class="line">      <span class="number">1025</span>, <span class="number">587</span>, <span class="number">8888</span>, <span class="number">199</span>, <span class="number">1720</span>,</span><br><span class="line">      <span class="number">113</span>, <span class="number">554</span>, <span class="number">256</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> num_pop_ports = <span class="keyword">sizeof</span>(pop_ports) / <span class="keyword">sizeof</span>(u16);   <span class="comment">//计算数组中元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (allportidx = <span class="number">0</span>; allportidx &lt; portcount; allportidx++) &#123; <span class="comment">//外部循环迭代所有的端口，内部循环迭代常用端口</span></span><br><span class="line">        <span class="comment">// 查看当前端口是否为常用端口</span></span><br><span class="line">        <span class="keyword">for</span> (popportidx = <span class="number">0</span>; popportidx &lt; num_pop_ports; popportidx++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ports[allportidx] == pop_ports[popportidx]) &#123;</span><br><span class="line">                <span class="comment">// 这个端口是常用的，把它换到开头附近。</span></span><br><span class="line">                <span class="keyword">if</span> (allportidx != earlyreplidx) &#123;</span><br><span class="line">                    ports[allportidx] = ports[earlyreplidx];</span><br><span class="line">                    ports[earlyreplidx] = pop_ports[popportidx];</span><br><span class="line">                &#125;</span><br><span class="line">                earlyreplidx++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scan_lists</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> tcp_count;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>* tcp_ports;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">scan_lists</span> <span class="title">ports</span>;</span></span><br><span class="line">    ports.tcp_count = <span class="number">7</span>;</span><br><span class="line">    ports.tcp_ports = (<span class="type">unsigned</span> <span class="type">short</span>*)<span class="built_in">malloc</span>(ports.tcp_count * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span>));</span><br><span class="line">    ports.tcp_ports[<span class="number">0</span>] = <span class="number">80</span>;</span><br><span class="line">    ports.tcp_ports[<span class="number">1</span>] = <span class="number">7777</span>;</span><br><span class="line">    ports.tcp_ports[<span class="number">2</span>] = <span class="number">443</span>;</span><br><span class="line">    ports.tcp_ports[<span class="number">3</span>] = <span class="number">22</span>;</span><br><span class="line">    ports.tcp_ports[<span class="number">4</span>] = <span class="number">2111</span>;</span><br><span class="line">    ports.tcp_ports[<span class="number">5</span>] = <span class="number">3389</span>;</span><br><span class="line">    ports.tcp_ports[<span class="number">6</span>] = <span class="number">8080</span>;</span><br><span class="line">	random_port_cheat(ports.tcp_ports, ports.tcp_count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TCP Ports:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ports.tcp_count; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ports.tcp_ports[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ports.tcp_ports);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后得到：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TCP Ports:</span><br><span class="line">80</span><br><span class="line">443</span><br><span class="line">22</span><br><span class="line">3389</span><br><span class="line">8080</span><br><span class="line">7777</span><br><span class="line">2111</span><br></pre></td></tr></table></figure>

<p>此函数会把在重要端口列表的端口放在前面</p>
<p>下面开始就是namp扫描的重点部分</p>
<p>nmap的10个扫描阶段：脚本预扫描 &gt; 目标枚举 &gt; 主机发现（ping扫描） &gt; 反向DNS解析 &gt; 端口扫描 &gt; 版本检测 &gt; 操作系统检测 &gt; Traceroute &gt; 脚本扫描 &gt; 输出&gt; 编写后扫描脚本<br><strong>位置</strong>：<strong>脚本预扫描</strong>：此阶段是可选的，默认扫描中不会发生，“脚本预扫描”选项是从 Nmap 脚本引擎调用脚本(NSE) 用于 dhcp-discover 等预扫描阶段。<strong>目标枚举</strong>：在此阶段，默认扫描方法中的第一个阶段，nmaps 仅包含有关要扫描的目标的信息，例如 IP 地址、主机、IP 范围等。<strong>主机发现（ping 扫描）</strong>：在此阶段，nmap 会了解哪些目标在线或可访问。<strong>反向 DNS 解析</strong>：在此阶段，nmap 将查找用于 IP 地址的主机名。<strong>端口扫描</strong>：Nmap 将发现端口及其状态：打开、关闭或已过滤。<strong>版本检测</strong>：在此阶段，nmap 将尝试了解上一阶段发现的开放端口中运行的软件版本，例如 apache 或 ftp 的版本。<strong>操作系统检测</strong>：nmap 将尝试了解目标的操作系统。<strong>Traceroute</strong>： nmap会发现目标在网络上的路由或网络中的所有路由。<strong>脚本扫描</strong>：此阶段是可选的，在此阶段执行NSE脚本，NSE脚本可以在扫描之前执行，扫描期间执行扫描及其之后，但都是可选的。<strong>输出</strong>：Nmap 向我们显示有关收集的数据的信息。<strong>扫描后脚本</strong>：扫描完成后运行脚本的可选阶段。（参考：<a target="_blank" rel="noopener" href="https://cn.linux-console.net/?p=15913%EF%BC%89">https://cn.linux-console.net/?p=15913）</a></p>
<p>下面是预扫描阶段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NOLUA       <span class="comment">//在没有定义 NOLUA 宏的情况下执行下面的代码块</span></span></span><br><span class="line">  <span class="keyword">if</span> (o.scriptupdatedb) &#123;   <span class="comment">//检查是否启用了更新脚本数据库</span></span><br><span class="line">    o.max_ips_to_scan = o.numhosts_scanned; <span class="comment">// 禁用警告？</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (o.servicescan)   <span class="comment">//是否启用了服务扫描</span></span><br><span class="line">    o.scriptversion = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (o.scriptversion || o.script || o.scriptupdatedb)  <span class="comment">//检查是否启用了脚本版本信息、脚本或更新脚本数据库</span></span><br><span class="line">    open_nse();   <span class="comment">//初始化NSE（nmap脚本引擎）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 运行脚本预扫描阶段 */</span></span><br><span class="line">  <span class="keyword">if</span> (o.script) &#123;   <span class="comment">//是否启用扫描</span></span><br><span class="line">    script_scan_results = get_script_scan_results_obj();            <span class="comment">//获取脚本扫描结果对象</span></span><br><span class="line">    script_scan(Targets, SCRIPT_PRE_SCAN);                          <span class="comment">//运行脚本的预扫描阶段</span></span><br><span class="line">    printscriptresults(script_scan_results, SCRIPT_PRE_SCAN);       <span class="comment">//打印脚本的预扫描结果</span></span><br><span class="line">    <span class="keyword">for</span> (ScriptResults::iterator it = script_scan_results-&gt;begin(); <span class="comment">//循环遍历脚本扫描结果对象中的元素</span></span><br><span class="line">        it != script_scan_results-&gt;end(); it++) &#123;</span><br><span class="line">      delete (*it);    <span class="comment">//删除当前元素指向的内存对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    script_scan_results-&gt;clear();   <span class="comment">//清空脚本扫描结果</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>根据不同的条件启用或禁用脚本相关的功能。如果启用了服务扫描的标志或脚本相关的标志，则初始化 NSE，并运行脚本的预扫描功能，输出扫描结果，然后清空脚本扫描结果对象中的数据。</p>
<p>接下来看看什么是预扫描，查看<code>script_scan()</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">script_scan</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt; &amp;targets, stype scantype)</span></span><br><span class="line">&#123;</span><br><span class="line">  o.current_scantype = scantype;</span><br><span class="line"></span><br><span class="line">  assert(L_NSE != <span class="literal">NULL</span>);</span><br><span class="line">  lua_settop(L_NSE, <span class="number">0</span>); <span class="comment">/* 清除堆栈 */</span></span><br><span class="line"></span><br><span class="line">  lua_pushcfunction(L_NSE, nseU_traceback);    <span class="comment">//用于Lua脚本中进行错误追踪</span></span><br><span class="line">  lua_pushcfunction(L_NSE, run_main);</span><br><span class="line">  lua_pushlightuserdata(L_NSE, &amp;targets);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (lua_pcall(L_NSE, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    error(<span class="string">&quot;%s: Script Engine Scan Aborted.\nAn error was thrown by the &quot;</span></span><br><span class="line">          <span class="string">&quot;engine: %s&quot;</span>, SCRIPT_ENGINE, lua_tostring(L_NSE, <span class="number">-1</span>));</span><br><span class="line">  lua_settop(L_NSE, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点来看这里的<code>lua_pushcfunction(L_NSE, run_main);</code>的<code>run_main()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">run_main</span> <span class="params">(lua_State *L)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt; *targets = (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target*&gt; *)</span><br><span class="line">      lua_touserdata(L, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 新建主机组 */</span></span><br><span class="line">  lua_newtable(L);</span><br><span class="line">  lua_setfield(L, LUA_REGISTRYINDEX, NSE_CURRENT_HOSTS);</span><br><span class="line"></span><br><span class="line">  lua_getfield(L, LUA_REGISTRYINDEX, NSE_MAIN);</span><br><span class="line">  assert(lua_isfunction(L, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* NSE主函数的第一个参数是目标列表。这是一个包含1-N个目标名称的列表。*/</span></span><br><span class="line">  lua_createtable(L, targets-&gt;size(), <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> targets_table = lua_gettop(L);</span><br><span class="line">  lua_getfield(L, LUA_REGISTRYINDEX, NSE_CURRENT_HOSTS);</span><br><span class="line">  <span class="type">int</span> current_hosts = lua_gettop(L);</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt;::iterator ti = targets-&gt;begin(); ti != targets-&gt;end(); ti++)</span><br><span class="line">  &#123;  <span class="comment">//迭代目标向量中的每个目标</span></span><br><span class="line">    Target *target = (Target *) *ti;</span><br><span class="line">    <span class="keyword">if</span> (target-&gt;timedOut(<span class="literal">NULL</span>)) &#123;   <span class="comment">//检查目标对象是否已超时</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *TargetName = target-&gt;TargetName();    <span class="comment">//获取目标对象的名称</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *targetipstr = target-&gt;targetipstr();  <span class="comment">//获取目标对象的IP地址</span></span><br><span class="line">    </span><br><span class="line">    lua_newtable(L);              <span class="comment">//创建新表</span></span><br><span class="line">    set_hostinfo(L, target);	  <span class="comment">//设置主机信息，存储在targets_table中</span></span><br><span class="line">    lua_rawseti(L, targets_table, lua_rawlen(L, targets_table) + <span class="number">1</span>); <span class="comment">//获取targets_table的长度，然后使用+1作为索引将该表存储在targets_table中</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 在 NSE_CURRENT_HOSTS 的 targetname 和 IP 下索引此目标，以便我们稍后检索它*/</span></span><br><span class="line">    <span class="keyword">if</span> (TargetName != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strcmp</span>(TargetName, <span class="string">&quot;&quot;</span>) != <span class="number">0</span>) &#123;   <span class="comment">//检查目标名称是否不为空</span></span><br><span class="line">      lua_pushstring(L, TargetName);    <span class="comment">//将目标名推入栈中</span></span><br><span class="line">      lua_pushlightuserdata(L, target); <span class="comment">//将目标对象推入栈中</span></span><br><span class="line">      lua_rawset(L, current_hosts); <span class="comment">/* 添加到 NSE_CURRENT_HOSTS */</span></span><br><span class="line">    &#125;</span><br><span class="line">    lua_pushstring(L, targetipstr);</span><br><span class="line">    lua_pushlightuserdata(L, target);</span><br><span class="line">    lua_rawset(L, current_hosts); <span class="comment">/* 添加到 NSE_CURRENT_HOSTS */</span></span><br><span class="line">  &#125;</span><br><span class="line">  lua_settop(L, targets_table);   <span class="comment">//栈顶的元素调整为targets_table</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 推入脚本扫描阶段类型。NSE主函数的第二个参数 */</span></span><br><span class="line">  <span class="keyword">switch</span> (o.current_scantype)  <span class="comment">//变量o.current_scantype的值来确定要推送到Lua栈中的表示脚本扫描阶段类型的字符串</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> SCRIPT_PRE_SCAN:</span><br><span class="line">      lua_pushliteral(L, NSE_PRE_SCAN);    <span class="comment">//表示脚本预扫描阶段</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SCRIPT_SCAN:</span><br><span class="line">      lua_pushliteral(L, NSE_SCAN);        <span class="comment">//表示脚本扫描阶段</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SCRIPT_POST_SCAN:</span><br><span class="line">      lua_pushliteral(L, NSE_POST_SCAN);   <span class="comment">//表示脚本扫描后阶段</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      fatal(<span class="string">&quot;%s: failed to set the script scan phase.\n&quot;</span>, SCRIPT_ENGINE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lua_call(L, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以看出，这里的 ”预扫描“ 并不是真正的扫描，没有进行主机发现、端口扫描等操作，而是将一些基本信息推入栈中</p>
<p>继续看<code>nmap_main()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o.ping_group_sz &lt; o.minHostGroupSz())</span><br><span class="line">  o.ping_group_sz = o.minHostGroupSz();</span><br><span class="line">HostGroupState <span class="title function_">hstate</span><span class="params">(o.ping_group_sz, o.randomize_hosts, argc, (<span class="type">const</span> <span class="type">char</span> **) argv)</span>;</span><br></pre></td></tr></table></figure>

<p>如果当前的 Ping 主机组大小小于最小主机组大小，则将其设置为最小主机组大小。然后，使用设置后的 Ping 主机组大小创建一个 <code>HostGroupState</code> 对象。</p>
<p>继续</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//根据已扫描的主机数量和端口信息，确定理想的扫描组大小，并将结果赋值给 ideal_scan_group_sz。对应：目标枚举</span></span><br><span class="line">    ideal_scan_group_sz = determineScanGroupSize(o.numhosts_scanned, &amp;ports);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Targets.size() &lt; ideal_scan_group_sz) &#123; <span class="comment">//在目标列表的大小小于理想扫描组大小时。对应：主机发现</span></span><br><span class="line">      o.current_scantype = HOST_DISCOVERY;         <span class="comment">//将当前扫描类型设置为主机发现</span></span><br><span class="line">      currenths = nexthost(&amp;hstate, exclude_group, &amp;ports, o.pingtype);  <span class="comment">//nexthost 函数根据主机组状态、排除的主机组、端口信息和 Ping 类型选择下一个要扫描的主机</span></span><br><span class="line">      <span class="keyword">if</span> (!currenths)  <span class="comment">//如果获取不到下一个主机，则跳出内部循环</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (currenths-&gt;flags &amp; HOST_UP &amp;&amp; !o.listscan)  <span class="comment">//如果当前主机可达，且不是列表扫描模式，则增加已扫描的主机数量</span></span><br><span class="line">        o.numhosts_up++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((o.noportscan &amp;&amp; !o.traceroute    <span class="comment">//如果没有端口扫描且不进行路由跟踪</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NOLUA</span></span><br><span class="line">           &amp;&amp; !o.script                     <span class="comment">//不包含脚本扫描</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          ) || o.listscan) &#123;</span><br><span class="line">        <span class="comment">/* We&#x27;re done with the hosts */</span></span><br><span class="line">        <span class="keyword">if</span> (currenths-&gt;flags &amp; HOST_UP || (o.verbose &amp;&amp; !o.openOnly())) &#123;  <span class="comment">//如果当前主机可达或者详细输出模式开启且不仅显示开放端口</span></span><br><span class="line">          xml_start_tag(<span class="string">&quot;host&quot;</span>);           <span class="comment">//开始一个名为 &quot;host&quot; 的 XML 标签</span></span><br><span class="line">          write_host_header(currenths);    <span class="comment">//写入主机的头部信息到日志</span></span><br><span class="line">          printmacinfo(currenths);         <span class="comment">//打印主机的 MAC 信息</span></span><br><span class="line">          <span class="comment">//  if (currenths-&gt;flags &amp; HOST_UP)</span></span><br><span class="line">          <span class="comment">//  log_write(LOG_PLAIN,&quot;\n&quot;);</span></span><br><span class="line">          printtimes(currenths);           <span class="comment">//打印主机的时间信息</span></span><br><span class="line">          xml_end_tag();                   <span class="comment">//结束 &quot;host&quot; 的 XML 标签</span></span><br><span class="line">          xml_newline();                   <span class="comment">//在 XML 中插入一个新行</span></span><br><span class="line">          log_flush_all();                 <span class="comment">//刷新日志。</span></span><br><span class="line">        &#125;</span><br><span class="line">        delete currenths;                  <span class="comment">//释放当前主机的内存</span></span><br><span class="line">        o.numhosts_scanned++;              <span class="comment">//增加已扫描的主机数量</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果没有限制最大扫描数量，或者当前已扫描的主机数量加上目标列表的大小小于最大扫描数量</span></span><br><span class="line">        <span class="keyword">if</span> (!o.max_ips_to_scan || o.max_ips_to_scan &gt; o.numhosts_scanned + Targets.size())</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (o.spoofsource) &#123;                 <span class="comment">//如果启用了源 IP 欺骗</span></span><br><span class="line">        o.SourceSockAddr(&amp;ss, &amp;sslen);     <span class="comment">//获取源 IP 的套接字地址和长度</span></span><br><span class="line">        currenths-&gt;setSourceSockAddr(&amp;ss, sslen);   <span class="comment">//将源 IP 的套接字地址和长度设置为当前主机的源 IP</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 我过去会检查 !currenths-&gt;weird_responses，但在某些罕见情况下，这些 IP 可以成功扫描端口，甚至连接 */</span></span><br><span class="line">      <span class="keyword">if</span> (!(currenths-&gt;flags &amp; HOST_UP)) &#123;   <span class="comment">//检测当前主机是否开启，如果未开启，执行下面代码</span></span><br><span class="line">        <span class="keyword">if</span> (o.verbose &amp;&amp; (!o.openOnly() || currenths-&gt;ports.hasOpenPorts())) &#123;   <span class="comment">//如果设置了详细输出，并且不仅仅是打开端口或当前主机存在打开的端口</span></span><br><span class="line">          xml_start_tag(<span class="string">&quot;host&quot;</span>);            <span class="comment">//同上</span></span><br><span class="line">          write_host_header(currenths);</span><br><span class="line">          xml_end_tag();</span><br><span class="line">          xml_newline();</span><br><span class="line">        &#125;</span><br><span class="line">        delete currenths;</span><br><span class="line">        o.numhosts_scanned++;</span><br><span class="line">        <span class="keyword">if</span> (!o.max_ips_to_scan || o.max_ips_to_scan &gt; o.numhosts_scanned + Targets.size())  <span class="comment">//检查是否达到了扫描的最大限制，如果限制未设置或者未达到最大限制，则继续下一轮循环</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//下面这段代码的功能是根据一系列条件设置扫描的源地址。首先，它检查是否设置了原始扫描，如果是，则尝试获取当前主机的源地址，并将其设置为扫描的源地址。如果无法获取当前主机的源地址，则尝试获取主机名，并通过解析主机名来获取源地址。如果主机名获取或解析失败，则输出错误信息。无论是通过获取当前主机的源地址还是解析主机名来获取源地址，都将获取的源地址设置为扫描的源地址。如果无法确定要使用的接口地址，则输出警告信息，并猜测使用的接口地址。最后，将源地址警告的标志设置为1，表示已经发出了源地址警告。</span></span><br><span class="line">      <span class="comment">//下面是一些详细解释</span></span><br><span class="line">      <span class="keyword">if</span> (o.RawScan()) &#123;   <span class="comment">//如果设置了原始扫描。对应：反向DNS解析 </span></span><br><span class="line">        <span class="keyword">if</span> (currenths-&gt;SourceSockAddr(<span class="literal">NULL</span>, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;  <span class="comment">//检查currenths指针所指向的对象是否可以获取当前主机的源地址，并设置扫描源地址</span></span><br><span class="line">          <span class="keyword">if</span> (o.SourceSockAddr(&amp;ss, &amp;sslen) == <span class="number">0</span>) &#123; <span class="comment">//检查o对象是否可以获取源地址，并将获取的地址存储在ss和sslen变量中</span></span><br><span class="line">            currenths-&gt;setSourceSockAddr(&amp;ss, sslen); <span class="comment">//将之前获取的源地址ss和sslen设置为扫描的源地址</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果无法获取源地址，检查获取主机名myname是否失败，或者调用resolve函数解析主机名失败</span></span><br><span class="line">            <span class="keyword">if</span> (gethostname(myname, FQDN_LEN) ||</span><br><span class="line">                resolve(myname, <span class="number">0</span>, &amp;ss, &amp;sslen, o.af()) != <span class="number">0</span>)</span><br><span class="line">              <span class="comment">//输出致命错误信息</span></span><br><span class="line">              fatal(<span class="string">&quot;Cannot get hostname!  Try using -S &lt;my_IP_address&gt; or -e &lt;interface to scan through&gt;\n&quot;</span>);</span><br><span class="line">			</span><br><span class="line">            </span><br><span class="line">            o.setSourceSockAddr(&amp;ss, sslen);          <span class="comment">//将之前获取的源地址ss和sslen设置为扫描的源地址</span></span><br><span class="line">            currenths-&gt;setSourceSockAddr(&amp;ss, sslen); <span class="comment">//将之前获取的源地址ss和sslen设置为扫描的源地址</span></span><br><span class="line">            <span class="keyword">if</span> (! sourceaddrwarning) &#123;</span><br><span class="line">              error(<span class="string">&quot;WARNING: We could not determine for sure which interface to use, so we are guessing %s .  If this is wrong, use -S &lt;my_IP_address&gt;.&quot;</span>,</span><br><span class="line">                    inet_socktop(&amp;ss));</span><br><span class="line">              sourceaddrwarning = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果当前主机没有设备名称，则抛出致命错误。</span></span><br><span class="line">        <span class="keyword">if</span> (!currenths-&gt;deviceName())</span><br><span class="line">          fatal(<span class="string">&quot;Do not have appropriate device name for target&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 组中的主机需要具有一定的同质性。必要时将该主机放入下一个组中。有关何时需要拆分的详细信息，请参阅 				            target_needs_new_hostgroup。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//如果目标主机数量大于0，并且需要为当前主机创建新的主机组，则返回主机</span></span><br><span class="line">        <span class="keyword">if</span> (Targets.size() &amp;&amp; target_needs_new_hostgroup(&amp;Targets[<span class="number">0</span>], Targets.size(), currenths)) &#123;</span><br><span class="line">          returnhost(&amp;hstate);</span><br><span class="line">          o.numhosts_up--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        o.decoys[o.decoyturn] = currenths-&gt;source();  <span class="comment">//将当前主机的源地址设置为诱饵地址。</span></span><br><span class="line">      &#125;</span><br><span class="line">      Targets.push_back(currenths);<span class="comment">//将当前主机对象添加到目标主机列表中。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Targets.size() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>; <span class="comment">/* 找不到更多目标 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置状态打印的变量</span></span><br><span class="line">    o.numhosts_scanning = Targets.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们的源必须在诱饵列表中设置，因为nexthost()调用可能会改变它（这个问题真的应该尽可能地修复）</span></span><br><span class="line">    <span class="keyword">if</span> (o.RawScan())</span><br><span class="line">      o.decoys[o.decoyturn] = Targets[<span class="number">0</span>]-&gt;source();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 我现在有用于扫描目标矢量的组 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!o.noportscan) &#123;  <span class="comment">//如果没有设置 noportscan，则执行端口扫描。对应：端口扫描</span></span><br><span class="line">      <span class="comment">// Ultra_scan 为我们设置了 o.scantype，所以我们不必担心</span></span><br><span class="line">      <span class="keyword">if</span> (o.synscan)  <span class="comment">//如果设置了 synscan，则使用 SYN 扫描方式对目标主机进行扫描</span></span><br><span class="line">        ultra_scan(Targets, &amp;ports, SYN_SCAN);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (o.ackscan)</span><br><span class="line">        ultra_scan(Targets, &amp;ports, ACK_SCAN);<span class="comment">//ACK 扫描方式，下面的代码类似</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (o.windowscan)</span><br><span class="line">        ultra_scan(Targets, &amp;ports, WINDOW_SCAN);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (o.finscan)</span><br><span class="line">        ultra_scan(Targets, &amp;ports, FIN_SCAN);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (o.xmasscan)</span><br><span class="line">        ultra_scan(Targets, &amp;ports, XMAS_SCAN);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (o.nullscan)</span><br><span class="line">        ultra_scan(Targets, &amp;ports, NULL_SCAN);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (o.maimonscan)</span><br><span class="line">        ultra_scan(Targets, &amp;ports, MAIMON_SCAN);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (o.udpscan)</span><br><span class="line">        ultra_scan(Targets, &amp;ports, UDP_SCAN);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (o.connectscan)</span><br><span class="line">        ultra_scan(Targets, &amp;ports, CONNECT_SCAN);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (o.sctpinitscan)</span><br><span class="line">        ultra_scan(Targets, &amp;ports, SCTP_INIT_SCAN);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (o.sctpcookieechoscan)</span><br><span class="line">        ultra_scan(Targets, &amp;ports, SCTP_COOKIE_ECHO_SCAN);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (o.ipprotscan)</span><br><span class="line">        ultra_scan(Targets, &amp;ports, IPPROT_SCAN);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 这些蹩脚的功能一次只能处理一个目标 */</span></span><br><span class="line">      <span class="keyword">if</span> (o.idlescan) &#123;</span><br><span class="line">        <span class="keyword">for</span> (targetno = <span class="number">0</span>; targetno &lt; Targets.size(); targetno++) &#123;</span><br><span class="line">          o.current_scantype = IDLE_SCAN;</span><br><span class="line">          keyWasPressed(); <span class="comment">// 检查是否应打印状态消息</span></span><br><span class="line">          <span class="comment">//调用idle_scan函数进行空闲扫描</span></span><br><span class="line">          idle_scan(Targets[targetno], ports.tcp_ports,</span><br><span class="line">                    ports.tcp_count, o.idleProxy, &amp;ports);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (o.bouncescan) &#123;</span><br><span class="line">        <span class="keyword">for</span> (targetno = <span class="number">0</span>; targetno &lt; Targets.size(); targetno++) &#123;</span><br><span class="line">          o.current_scantype = BOUNCE_SCAN;</span><br><span class="line">          keyWasPressed(); <span class="comment">// 检查是否应打印状态消息</span></span><br><span class="line">          <span class="keyword">if</span> (ftp.sd &lt;= <span class="number">0</span>)</span><br><span class="line">            ftp_anon_connect(&amp;ftp);   <span class="comment">//进行FTP匿名连接</span></span><br><span class="line">          <span class="keyword">if</span> (ftp.sd &gt; <span class="number">0</span>)</span><br><span class="line">            bounce_scan(Targets[targetno], ports.tcp_ports, ports.tcp_count, &amp;ftp); <span class="comment">//进行反弹扫描</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (o.servicescan) &#123;</span><br><span class="line">        o.current_scantype = SERVICE_SCAN;</span><br><span class="line">        service_scan(Targets);        <span class="comment">//对目标进行服务扫描。对应：版本检测</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o.osscan) &#123;</span><br><span class="line">      OSScan os_engine;</span><br><span class="line">      os_engine.os_scan(Targets);   <span class="comment">//对目标进行操作系统扫描。对应：操作系统检测</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o.traceroute)</span><br><span class="line">      traceroute(Targets);          <span class="comment">//对目标进行路由追踪。对应：Traceroute</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NOLUA</span></span><br><span class="line">    <span class="keyword">if</span> (o.script || o.scriptversion) &#123;</span><br><span class="line">      script_scan(Targets, SCRIPT_SCAN);  <span class="comment">//对目标进行脚本扫描。对应：脚本扫描</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">//下面这部分代码是对每个目标进行输出操作。首先检查目标是否超时，如果超时，则输出超时信息。否则进行一些列打印、输出操作。对应：输出</span></span><br><span class="line">    <span class="keyword">for</span> (targetno = <span class="number">0</span>; targetno &lt; Targets.size(); targetno++) &#123;</span><br><span class="line">      currenths = Targets[targetno];</span><br><span class="line">      <span class="comment">/* Now I can do the output and such for each host */</span></span><br><span class="line">      <span class="keyword">if</span> (currenths-&gt;timedOut(<span class="literal">NULL</span>)) &#123;</span><br><span class="line">        xml_open_start_tag(<span class="string">&quot;host&quot;</span>);</span><br><span class="line">        xml_attribute(<span class="string">&quot;starttime&quot;</span>, <span class="string">&quot;%lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>) currenths-&gt;StartTime());</span><br><span class="line">        xml_attribute(<span class="string">&quot;endtime&quot;</span>, <span class="string">&quot;%lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>) currenths-&gt;EndTime());</span><br><span class="line">        xml_attribute(<span class="string">&quot;timedout&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        xml_close_start_tag();</span><br><span class="line">        write_host_header(currenths);</span><br><span class="line">        printtimes(currenths);</span><br><span class="line">        xml_end_tag(); <span class="comment">/* host */</span></span><br><span class="line">        xml_newline();</span><br><span class="line">        log_write(LOG_PLAIN, <span class="string">&quot;Skipping host %s due to host timeout\n&quot;</span>,</span><br><span class="line">                  currenths-&gt;NameIP(hostname, <span class="keyword">sizeof</span>(hostname)));</span><br><span class="line">        log_write(LOG_MACHINE, <span class="string">&quot;Host: %s (%s)\tStatus: Timeout\n&quot;</span>,</span><br><span class="line">                  currenths-&gt;targetipstr(), currenths-&gt;HostName());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* --open means don&#x27;t show any hosts without open ports. */</span></span><br><span class="line">        <span class="keyword">if</span> (o.openOnly() &amp;&amp; !currenths-&gt;ports.hasOpenPorts())</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        xml_open_start_tag(<span class="string">&quot;host&quot;</span>);</span><br><span class="line">        xml_attribute(<span class="string">&quot;starttime&quot;</span>, <span class="string">&quot;%lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>) currenths-&gt;StartTime());</span><br><span class="line">        xml_attribute(<span class="string">&quot;endtime&quot;</span>, <span class="string">&quot;%lu&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>) currenths-&gt;EndTime());</span><br><span class="line">        xml_close_start_tag();</span><br><span class="line">        write_host_header(currenths);</span><br><span class="line">        printportoutput(currenths, &amp;currenths-&gt;ports);</span><br><span class="line">        printmacinfo(currenths);</span><br><span class="line">        printosscanoutput(currenths);</span><br><span class="line">        printserviceinfooutput(currenths);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NOLUA</span></span><br><span class="line">        printhostscriptresults(currenths);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (o.traceroute)</span><br><span class="line">          printtraceroute(currenths);</span><br><span class="line">        printtimes(currenths);</span><br><span class="line">        log_write(LOG_PLAIN | LOG_MACHINE, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        xml_end_tag(); <span class="comment">/* host */</span></span><br><span class="line">        xml_newline();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log_flush_all();  <span class="comment">//将所有日志刷新到磁盘</span></span><br><span class="line"></span><br><span class="line">    o.numhosts_scanned += Targets.size(); <span class="comment">//增加已扫描主机的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放所有目标 */</span></span><br><span class="line">    <span class="keyword">while</span> (!Targets.empty()) &#123;</span><br><span class="line">      currenths = Targets.back();</span><br><span class="line">      delete currenths;</span><br><span class="line">      Targets.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    o.numhosts_scanning = <span class="number">0</span>;   <span class="comment">//将正在扫描的主机数量设置为0</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (!o.max_ips_to_scan || o.max_ips_to_scan &gt; o.numhosts_scanned);<span class="comment">//没有设置扫描限制或者扫描的主机数量小于o.max_ips_to_scan，则继续执行循环</span></span><br></pre></td></tr></table></figure>

<p>上面这个循环可以说是整个扫描的核心部分，主要是根据配置进行主机发现、端口扫描、操作系统识别、跟踪路由以及脚本扫描，输出扫描结果和统计信息。至于如何实现的各种功能则被独立封装，接下来我们挨个看具体如何实现</p>
<p>先看<code>ultra_scan()</code>函数，他的功能是端口扫描，在上面的代码可以看到他有多个可选参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ultra_scan</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt; &amp;Targets, <span class="type">const</span> <span class="keyword">struct</span> scan_lists *ports,</span></span><br><span class="line"><span class="params">                stype scantype, <span class="keyword">struct</span> timeout_info *to)</span> &#123;</span><br><span class="line">  o.current_scantype = scantype;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Targets.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">  <span class="comment">//在 Windows 平台下，不支持对本地主机进行扫描，针对本地进行扫描时会跳过该操作</span></span><br><span class="line">  <span class="keyword">if</span> (g_has_npcap_loopback == <span class="number">0</span> &amp;&amp; scantype != CONNECT_SCAN &amp;&amp; Targets[<span class="number">0</span>]-&gt;ifType() == devt_loopback) &#123;</span><br><span class="line">    log_write(LOG_STDOUT, <span class="string">&quot;Skipping %s against %s because Windows does not support scanning your own machine (localhost) this way.\n&quot;</span>, scantype2str(scantype), Targets[<span class="number">0</span>]-&gt;NameIP());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置状态打印的变量</span></span><br><span class="line">  o.numhosts_scanning = Targets.size();</span><br><span class="line"></span><br><span class="line">  UltraScanInfo <span class="title function_">USI</span><span class="params">(Targets, ports, scantype)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将所有有效载荷加载到映射表中。仅用于原始扫描。 */</span></span><br><span class="line">  <span class="keyword">if</span> (USI.udp_scan || (USI.ping_scan &amp;&amp; USI.ptech.rawudpscan) ) &#123;</span><br><span class="line">    init_payloads(); <span class="comment">//如果是 UDP 扫描或者使用原始 ICMP 扫描并启用了原始 UDP 扫描技术，则初始化负载数据</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (USI.gstats-&gt;numprobes &lt;= <span class="number">0</span>) &#123;  <span class="comment">// 检查扫描中使用的探测请求数量是否小于等于 0</span></span><br><span class="line">    <span class="keyword">if</span> (o.debugging) &#123;</span><br><span class="line">      log_write(LOG_STDOUT, <span class="string">&quot;Skipping %s: no probes to send\n&quot;</span>, scantype2str(scantype));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 使用请求的超时。 */</span></span><br><span class="line">  <span class="keyword">if</span> (to != <span class="literal">NULL</span>)</span><br><span class="line">    USI.gstats-&gt;to = *to;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (o.verbose) &#123;         <span class="comment">//检查是否启用详细输出模式</span></span><br><span class="line">    <span class="type">char</span> targetstr[<span class="number">128</span>];</span><br><span class="line">    <span class="type">bool</span> plural = (Targets.size() != <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!plural) &#123;    <span class="comment">//将第一个目标的名称和IP地址存储在targetstr中，或者将Targets的大小以字符串形式存储在targetstr中</span></span><br><span class="line">      (*(Targets.begin()))-&gt;NameIP(targetstr, <span class="keyword">sizeof</span>(targetstr));</span><br><span class="line">    &#125; <span class="keyword">else</span> Snprintf(targetstr, <span class="keyword">sizeof</span>(targetstr), <span class="string">&quot;%d hosts&quot;</span>, (<span class="type">int</span>) Targets.size());</span><br><span class="line">    log_write(LOG_STDOUT, <span class="string">&quot;Scanning %s [%d port%s%s]\n&quot;</span>, targetstr, USI.gstats-&gt;numprobes, (USI.gstats-&gt;numprobes != <span class="number">1</span>) ? <span class="string">&quot;s&quot;</span> : <span class="string">&quot;&quot;</span>, plural ? <span class="string">&quot;/host&quot;</span> : <span class="string">&quot;&quot;</span>);   <span class="comment">//打印扫描的目标主机和端口信息</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (USI.isRawScan())</span><br><span class="line">    begin_sniffer(&amp;USI, Targets);    <span class="comment">//如果是原始扫描（raw scan），则启动数据包嗅探器。</span></span><br><span class="line">  <span class="comment">/* 否则，就不需要嗅探器了！*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!USI.incompleteHostsEmpty()) &#123;   <span class="comment">//进入主循环，直到所有主机的扫描任务完成</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">    <span class="comment">// 重置系统空闲计时器以避免进入睡眠状态</span></span><br><span class="line">    SetThreadExecutionState(ES_SYSTEM_REQUIRED);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    doAnyPings(&amp;USI); <span class="comment">//发送 ICMP 探测请求</span></span><br><span class="line">    doAnyOutstandingRetransmits(&amp;USI); <span class="comment">// 从 probes_outstanding 重新传输</span></span><br><span class="line">    <span class="comment">/* 从 retry_stack 重新传输——出于内存消耗的原因，在 OutstandingRetransmits 之后进行 */</span></span><br><span class="line">    doAnyRetryStackRetransmits(&amp;USI);  <span class="comment">//处理重试栈中的探测请求的重传</span></span><br><span class="line">    doAnyNewProbes(&amp;USI);              <span class="comment">//发送新的探测请求</span></span><br><span class="line">    gettimeofday(&amp;USI.now, <span class="literal">NULL</span>);      <span class="comment">//获取当前时间</span></span><br><span class="line">    <span class="comment">// printf(&quot;TRACE: Finished doAnyNewProbes() at %.4fs\n&quot;, o.TimeSinceStartMS(&amp;USI.now) / 1000.0);</span></span><br><span class="line">    printAnyStats(&amp;USI);               <span class="comment">//打印当前的扫描统计信息</span></span><br><span class="line">    waitForResponses(&amp;USI);            <span class="comment">//等待接收到所有探测请求的响应</span></span><br><span class="line">    gettimeofday(&amp;USI.now, <span class="literal">NULL</span>);      <span class="comment">//获取当前时间</span></span><br><span class="line">    <span class="comment">// printf(&quot;TRACE: Finished waitForResponses() at %.4fs\n&quot;, o.TimeSinceStartMS(&amp;USI.now) / 1000.0);</span></span><br><span class="line">    processData(&amp;USI);                 <span class="comment">//处理接收到的响应数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (keyWasPressed()) &#123;             <span class="comment">//检查是否按下了键盘上的键</span></span><br><span class="line">      <span class="comment">// 这将打印类似以下内容</span></span><br><span class="line">      <span class="comment">// SYN Stealth Scan Timing: About 1.14% done; ETC: 15:01 (0:43:23 remaining);</span></span><br><span class="line">      USI.SPM-&gt;printStats(USI.getCompletionFraction(), <span class="literal">NULL</span>);  <span class="comment">//打印当前的扫描进度和速率信息</span></span><br><span class="line">      <span class="keyword">if</span> (o.debugging) &#123;</span><br><span class="line">        <span class="comment">/* 在获取当前费率时不要进行更新，否则我们可能会因为刚刚进行了可能很长的等待ForResponses而没有发送任何数据包而出现异常            （费率过低）。*/</span></span><br><span class="line">        USI.log_current_rates(LOG_STDOUT, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      log_flush(LOG_STDOUT);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  USI.send_rate_meter.stop(&amp;USI.now);   <span class="comment">//停止发送速率计量器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 保存计算出的超时值。 */</span></span><br><span class="line">  <span class="keyword">if</span> (to != <span class="literal">NULL</span>)</span><br><span class="line">    *to = USI.gstats-&gt;to;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (o.verbose) &#123;  <span class="comment">//检查是否启用详细输出模式</span></span><br><span class="line">    <span class="type">char</span> additional_info[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">if</span> (USI.gstats-&gt;num_hosts_timedout == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">if</span> (USI.ping_scan) &#123;</span><br><span class="line">        Snprintf(additional_info, <span class="keyword">sizeof</span>(additional_info), <span class="string">&quot;%lu total hosts&quot;</span>,</span><br><span class="line">                 (<span class="type">unsigned</span> <span class="type">long</span>) Targets.size());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Snprintf(additional_info, <span class="keyword">sizeof</span>(additional_info), <span class="string">&quot;%lu total ports&quot;</span>,</span><br><span class="line">                 (<span class="type">unsigned</span> <span class="type">long</span>) USI.gstats-&gt;numprobes * Targets.size());</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span> Snprintf(additional_info, <span class="keyword">sizeof</span>(additional_info), <span class="string">&quot;%d %s timed out&quot;</span>,</span><br><span class="line">                    USI.gstats-&gt;num_hosts_timedout,</span><br><span class="line">                    (USI.gstats-&gt;num_hosts_timedout == <span class="number">1</span>) ? <span class="string">&quot;host&quot;</span> : <span class="string">&quot;hosts&quot;</span>);</span><br><span class="line">    USI.SPM-&gt;endTask(<span class="literal">NULL</span>, additional_info);  <span class="comment">//印扫描任务的结束信息</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (o.debugging)</span><br><span class="line">    USI.log_overall_rates(LOG_STDOUT);   <span class="comment">//打印整体的扫描速率信息</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (o.debugging &gt; <span class="number">2</span> &amp;&amp; USI.pd != <span class="literal">NULL</span>)</span><br><span class="line">    pcap_print_stats(LOG_PLAIN, USI.pd);  <span class="comment">//打印用于嗅探数据包的统计信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码涉及到了<code>UltraScanInfo USI</code>，我们先看看他是如何实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UltraScanInfo</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">  UltraScanInfo();</span><br><span class="line">  UltraScanInfo(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt; &amp;Targets, <span class="type">const</span> <span class="keyword">struct</span> scan_lists *pts, stype scantype) &#123;</span><br><span class="line">    Init(Targets, pts, scantype);</span><br><span class="line">  &#125;</span><br><span class="line">  ~UltraScanInfo();</span><br><span class="line">  <span class="comment">/* 如果使用默认构造函数创建对象，则必须调用 Init */</span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt; &amp;Targets, <span class="type">const</span> <span class="keyword">struct</span> scan_lists *pts, stype scantp)</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>他下面的代码先不看，跟踪这里的<code>Init</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">UltraScanInfo::Init</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt; &amp;Targets, <span class="type">const</span> <span class="keyword">struct</span> scan_lists *pts, stype scantp)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> targetno = <span class="number">0</span>;</span><br><span class="line">  HostScanStats *hss;</span><br><span class="line">  <span class="type">int</span> num_timedout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  ports = pts;</span><br><span class="line"></span><br><span class="line">  seqmask = get_random_u32();</span><br><span class="line">  scantype = scantp;</span><br><span class="line">  SPM = new ScanProgressMeter(scantype2str(scantype));</span><br><span class="line">  send_rate_meter.start(&amp;now);</span><br><span class="line">  tcp_scan = udp_scan = sctp_scan = prot_scan = <span class="literal">false</span>;</span><br><span class="line">  ping_scan = noresp_open_scan = ping_scan_arp = ping_scan_nd = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">memset</span>((<span class="type">char</span> *) &amp;ptech, <span class="number">0</span>, <span class="keyword">sizeof</span>(ptech));</span><br><span class="line">  perf.init();</span><br><span class="line">  <span class="keyword">switch</span> (scantype) &#123;</span><br><span class="line">  <span class="keyword">case</span> FIN_SCAN:</span><br><span class="line">  <span class="keyword">case</span> XMAS_SCAN:</span><br><span class="line">  <span class="keyword">case</span> MAIMON_SCAN:</span><br><span class="line">  <span class="keyword">case</span> NULL_SCAN:</span><br><span class="line">    noresp_open_scan = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">case</span> ACK_SCAN:</span><br><span class="line">  <span class="keyword">case</span> CONNECT_SCAN:</span><br><span class="line">  <span class="keyword">case</span> SYN_SCAN:</span><br><span class="line">  <span class="keyword">case</span> WINDOW_SCAN:</span><br><span class="line">    tcp_scan = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> UDP_SCAN:</span><br><span class="line">    noresp_open_scan = <span class="literal">true</span>;</span><br><span class="line">    udp_scan = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> SCTP_INIT_SCAN:</span><br><span class="line">  <span class="keyword">case</span> SCTP_COOKIE_ECHO_SCAN:</span><br><span class="line">    sctp_scan = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> IPPROT_SCAN:</span><br><span class="line">    noresp_open_scan = <span class="literal">true</span>;</span><br><span class="line">    prot_scan = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PING_SCAN:</span><br><span class="line">    ping_scan = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/* What kind of pings are we doing? */</span></span><br><span class="line">    <span class="keyword">if</span> (o.pingtype &amp; (PINGTYPE_ICMP_PING | PINGTYPE_ICMP_MASK | PINGTYPE_ICMP_TS))</span><br><span class="line">      ptech.rawicmpscan = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (o.pingtype &amp; PINGTYPE_UDP)</span><br><span class="line">      ptech.rawudpscan = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (o.pingtype &amp; PINGTYPE_SCTP_INIT)</span><br><span class="line">      ptech.rawsctpscan = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (o.pingtype &amp; PINGTYPE_TCP) &#123;</span><br><span class="line">      <span class="keyword">if</span> (o.isr00t)</span><br><span class="line">        ptech.rawtcpscan = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ptech.connecttcpscan = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o.pingtype &amp; PINGTYPE_PROTO)</span><br><span class="line">      ptech.rawprotoscan = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (o.pingtype &amp; PINGTYPE_CONNECTTCP)</span><br><span class="line">      ptech.connecttcpscan = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PING_SCAN_ARP:</span><br><span class="line">    ping_scan = <span class="literal">true</span>;</span><br><span class="line">    ping_scan_arp = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/* 对于 ARP 和 ND 扫描，我们更频繁地发送 ping。否则，在 </span></span><br><span class="line"><span class="comment">     * RLD_TIME_MS 后开始发送重新传输之前，我们无法注意到丢包。 */</span></span><br><span class="line">    perf.pingtime = RLD_TIME_MS * <span class="number">1000</span> / <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PING_SCAN_ND:</span><br><span class="line">    ping_scan = <span class="literal">true</span>;</span><br><span class="line">    ping_scan_nd = <span class="literal">true</span>;</span><br><span class="line">    perf.pingtime = RLD_TIME_MS * <span class="number">1000</span> / <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set_default_port_state(Targets, scantype);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;lastCompletedHostRemoval, <span class="number">0</span>, <span class="keyword">sizeof</span>(lastCompletedHostRemoval));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (targetno = <span class="number">0</span>; targetno &lt; Targets.size(); targetno++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Targets[targetno]-&gt;timedOut(&amp;now)) &#123;</span><br><span class="line">      num_timedout++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hss = new HostScanStats(Targets[targetno], this);</span><br><span class="line">    incompleteHosts.insert(hss);</span><br><span class="line">  &#125;</span><br><span class="line">  numInitialTargets = Targets.size();</span><br><span class="line">  nextI = incompleteHosts.begin();</span><br><span class="line"></span><br><span class="line">  gstats = new GroupScanStats(this); <span class="comment">/* 仔细查看USI中的几个元素 - 注意顺序 */</span></span><br><span class="line">  gstats-&gt;num_hosts_timedout += num_timedout;</span><br><span class="line"></span><br><span class="line">  pd = <span class="literal">NULL</span>;</span><br><span class="line">  rawsd = <span class="number">-1</span>;</span><br><span class="line">  ethsd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 看看我们是否需要以太网句柄或原始套接字。基本上，如果我们没有进行TCP连接扫描，或者我们正在进行需要它的ping扫描。*/</span></span><br><span class="line">  <span class="keyword">if</span> (isRawScan()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ping_scan_arp || (ping_scan_nd &amp;&amp; o.sendpref != PACKET_SEND_IP_STRONG) || ((o.sendpref &amp; PACKET_SEND_ETH) &amp;&amp;</span><br><span class="line">        (Targets[<span class="number">0</span>]-&gt;ifType() == devt_ethernet</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">        || (g_has_npcap_loopback &amp;&amp; Targets[<span class="number">0</span>]-&gt;ifType() == devt_loopback)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        ))) &#123;</span><br><span class="line">      <span class="comment">/* 我们将使用dnet发送以太网数据包 */</span></span><br><span class="line">      ethsd = eth_open_cached(Targets[<span class="number">0</span>]-&gt;deviceName());</span><br><span class="line">      <span class="keyword">if</span> (ethsd == <span class="literal">NULL</span>)</span><br><span class="line">        fatal(<span class="string">&quot;dnet: Failed to open device %s&quot;</span>, Targets[<span class="number">0</span>]-&gt;deviceName());</span><br><span class="line">      rawsd = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">      win32_fatal_raw_sockets(Targets[<span class="number">0</span>]-&gt;deviceName());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      rawsd = nmap_raw_socket();</span><br><span class="line">      <span class="keyword">if</span> (rawsd &lt; <span class="number">0</span>)</span><br><span class="line">        pfatal(<span class="string">&quot;Couldn&#x27;t open a raw socket. &quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(sun) &amp;&amp; defined(__SVR4)</span></span><br><span class="line">        <span class="string">&quot;In Solaris shared-IP non-global zones, this requires the PRIV_NET_RAWACCESS privilege. &quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="string">&quot;Error&quot;</span></span><br><span class="line">        );</span><br><span class="line">      <span class="comment">/* 我们不想取消阻塞套接字，因为我们想等待内核发送缓冲区填满而不是得到ENOBUF，</span></span><br><span class="line"><span class="comment">         而且我们无论如何都不会在套接字上接收 unblock_socket(rawsd)  */</span></span><br><span class="line">      ethsd = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 原始扫描类型也需要知道源IP。 */</span></span><br><span class="line">    Targets[<span class="number">0</span>]-&gt;SourceSockAddr(&amp;sourceSockAddr, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  base_port = UltraScanInfo::increment_base_port();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里就是对类似<code>ultra_scan(Targets, &amp;ports, SYN_SCAN);</code>这样的代码中第三个参数的处理。这段代码主要是根据输入的参数进行初始化操作，设置扫描类型、端口状态等，并创建相关的对象和数据结构用于扫描过程。</p>
<p>接着跟进<code>doAnyPings(&amp;USI);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">doAnyPings</span><span class="params">(UltraScanInfo *USI)</span> &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;HostScanStats *, HssPredicate&gt;::iterator hostI;</span><br><span class="line">  HostScanStats *hss = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;USI-&gt;now, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">/* 第一个单主机 ping */</span></span><br><span class="line">  <span class="keyword">for</span> (hostI = USI-&gt;incompleteHosts.begin();   <span class="comment">//循环遍历USI-&gt;incompleteHosts容器中的每一个元素</span></span><br><span class="line">       hostI != USI-&gt;incompleteHosts.end(); hostI++) &#123;</span><br><span class="line">    hss = *hostI;</span><br><span class="line">    <span class="keyword">if</span> (hss-&gt;target-&gt;pingprobe.type != PS_NONE &amp;&amp;</span><br><span class="line">        hss-&gt;rld.rld_waiting == <span class="literal">false</span> &amp;&amp;</span><br><span class="line">        hss-&gt;numprobes_sent &gt;= hss-&gt;lastping_sent_numprobes + <span class="number">10</span> &amp;&amp;</span><br><span class="line">        TIMEVAL_SUBTRACT(USI-&gt;now, hss-&gt;lastrcvd) &gt; USI-&gt;perf.pingtime &amp;&amp;</span><br><span class="line">        TIMEVAL_SUBTRACT(USI-&gt;now, hss-&gt;lastping_sent) &gt; USI-&gt;perf.pingtime &amp;&amp;</span><br><span class="line">        USI-&gt;gstats-&gt;sendOK(<span class="literal">NULL</span>) &amp;&amp; hss-&gt;sendOK(<span class="literal">NULL</span>)) &#123;</span><br><span class="line">      sendPingProbe(USI, hss);   <span class="comment">//调用sendPingProbe函数发送ping探测</span></span><br><span class="line">      hss-&gt;lastping_sent = USI-&gt;now;</span><br><span class="line">      hss-&gt;lastping_sent_numprobes = hss-&gt;numprobes_sent;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 接下来是全球ping。我们一次发送的ping不会超过一个。 */</span></span><br><span class="line">  <span class="keyword">if</span> (USI-&gt;gstats-&gt;pinghost != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">      USI-&gt;gstats-&gt;pinghost-&gt;target-&gt;pingprobe.type != PS_NONE &amp;&amp;</span><br><span class="line">      USI-&gt;gstats-&gt;pinghost-&gt;num_probes_active == <span class="number">0</span> &amp;&amp;</span><br><span class="line">      USI-&gt;gstats-&gt;probes_sent &gt;= USI-&gt;gstats-&gt;lastping_sent_numprobes + <span class="number">20</span> &amp;&amp;</span><br><span class="line">      TIMEVAL_SUBTRACT(USI-&gt;now, USI-&gt;gstats-&gt;lastrcvd) &gt; USI-&gt;perf.pingtime &amp;&amp;</span><br><span class="line">      TIMEVAL_SUBTRACT(USI-&gt;now, USI-&gt;gstats-&gt;lastping_sent) &gt; USI-&gt;perf.pingtime &amp;&amp;</span><br><span class="line">      USI-&gt;gstats-&gt;sendOK(<span class="literal">NULL</span>)) &#123;</span><br><span class="line">    sendGlobalPingProbe(USI);   <span class="comment">//调用sendGlobalPingProbe函数发送全球ping探测</span></span><br><span class="line">    USI-&gt;gstats-&gt;lastping_sent = USI-&gt;now;</span><br><span class="line">    USI-&gt;gstats-&gt;lastping_sent_numprobes = USI-&gt;gstats-&gt;probes_sent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数根据一系列条件判断是否需要发送ping探测，并调用相应的函数执行ping操作</p>
<p>跟进<code>sendPingProbe(USI, hss);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sendPingProbe</span><span class="params">(UltraScanInfo *USI, HostScanStats *hss)</span> &#123;</span><br><span class="line">  <span class="type">tryno_t</span> tryno = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  tryno.fields.isPing = <span class="number">1</span>;</span><br><span class="line">  tryno.fields.seqnum = hss-&gt;nextPingSeq();</span><br><span class="line"></span><br><span class="line">  probespec *pingprobe = &amp;hss-&gt;target-&gt;pingprobe;</span><br><span class="line">  <span class="keyword">switch</span> (pingprobe-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> PS_CONNECTTCP:</span><br><span class="line">      sendConnectScanProbe(USI, hss, pingprobe-&gt;pd.tcp.dport, tryno);<span class="comment">//发送连接型TCP扫描探测</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PS_TCP:</span><br><span class="line">    <span class="keyword">case</span> PS_UDP:</span><br><span class="line">    <span class="keyword">case</span> PS_SCTP:</span><br><span class="line">    <span class="keyword">case</span> PS_PROTO:</span><br><span class="line">    <span class="keyword">case</span> PS_ICMP:</span><br><span class="line">      sendIPScanProbe(USI, hss, pingprobe, tryno);<span class="comment">//发送IP层扫描探测</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PS_ARP:</span><br><span class="line">      sendArpScanProbe(USI, hss, tryno);<span class="comment">//发送ARP扫描探测</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PS_ND:</span><br><span class="line">      sendNDScanProbe(USI, hss, tryno);<span class="comment">//发送ND扫描探测</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      assert(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (o.debugging &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">char</span> tmpbuf[<span class="number">64</span>];</span><br><span class="line">    log_write(LOG_PLAIN, <span class="string">&quot;Ultrascan PING SENT to %s [%s]\n&quot;</span>, hss-&gt;target-&gt;targetipstr(),</span><br><span class="line">              probespec2ascii(pingprobe, tmpbuf, <span class="keyword">sizeof</span>(tmpbuf)));</span><br><span class="line">  &#125;</span><br><span class="line">  USI-&gt;gstats-&gt;probes_sent++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进<code>sendConnectScanProbe(USI, hss, pingprobe-&gt;pd.tcp.dport, tryno);//发送连接型TCP扫描探测</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">UltraProbe *<span class="title function_">sendConnectScanProbe</span><span class="params">(UltraScanInfo *USI, HostScanStats *hss,</span></span><br><span class="line"><span class="params">                                 u16 destport, <span class="type">tryno_t</span> tryno)</span> &#123;</span><br><span class="line"></span><br><span class="line">  UltraProbe *probe = new UltraProbe();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;UltraProbe *&gt;::iterator probeI;</span><br><span class="line">  <span class="type">int</span> rc;</span><br><span class="line">  <span class="type">int</span> connect_errno = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">sock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">sin</span> =</span> (<span class="keyword">struct</span> sockaddr_in *) &amp;sock;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_IPV6</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> *<span class="title">sin6</span> =</span> (<span class="keyword">struct</span> sockaddr_in6 *) &amp;sock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">size_t</span> socklen;</span><br><span class="line">  ConnectProbe *CP;</span><br><span class="line">  ConnectScanInfo *CSI = USI-&gt;gstats-&gt;CSI;</span><br><span class="line"></span><br><span class="line">  probe-&gt;tryno = tryno;</span><br><span class="line">  <span class="comment">/* 首先构建探测器 */</span></span><br><span class="line">  probe-&gt;setConnect(destport);   <span class="comment">//设置probe的连接型探测规范，其中destport为目标端口号</span></span><br><span class="line">  CP = probe-&gt;CP();</span><br><span class="line">  <span class="comment">/* 启动连接 */</span></span><br><span class="line">  CP-&gt;sd = CSI-&gt;getSocket();</span><br><span class="line">  assert(CP-&gt;sd &gt; <span class="number">0</span>);</span><br><span class="line">  unblock_socket(CP-&gt;sd);</span><br><span class="line">  init_socket(CP-&gt;sd);</span><br><span class="line">  set_ttl(CP-&gt;sd, o.ttl);</span><br><span class="line">  <span class="keyword">if</span> (o.ipoptionslen)</span><br><span class="line">    set_ipoptions(CP-&gt;sd, o.ipoptions, o.ipoptionslen);</span><br><span class="line">  <span class="keyword">if</span> (hss-&gt;target-&gt;TargetSockAddr(&amp;sock, &amp;socklen) != <span class="number">0</span>) &#123;  <span class="comment">//获取目标主机的套接字地址信息，并将其存储在sock和socklen中</span></span><br><span class="line">    fatal(<span class="string">&quot;Failed to get target socket address in %s&quot;</span>, __func__);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">sin</span>-&gt;sin_family == AF_INET) <span class="comment">//如果sin-&gt;sin_family为AF_INET（IPv4地址），</span></span><br><span class="line">                                  <span class="comment">//则将probe的目标端口号设置为probe-&gt;pspec()-&gt;pd.tcp.dport的值，转换为网络字节序</span></span><br><span class="line">    <span class="built_in">sin</span>-&gt;sin_port = htons(probe-&gt;pspec()-&gt;pd.tcp.dport);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_IPV6</span></span><br><span class="line">  <span class="keyword">else</span> sin6-&gt;sin6_port = htons(probe-&gt;pspec()-&gt;pd.tcp.dport);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  probe-&gt;sent = USI-&gt;now;</span><br><span class="line">  <span class="comment">/* 我们不会记录连接探测的字节数。 */</span></span><br><span class="line">  hss-&gt;probeSent(<span class="number">0</span>);    <span class="comment">//每当向此主机发送探测时，都会调用该函数。负责更新扫描延迟和速率限制变量。</span></span><br><span class="line">  rc = connect(CP-&gt;sd, (<span class="keyword">struct</span> sockaddr *)&amp;sock, socklen);  <span class="comment">//发起连接请求</span></span><br><span class="line">  gettimeofday(&amp;USI-&gt;now, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (rc == <span class="number">-1</span>)   <span class="comment">//如果连接请求失败</span></span><br><span class="line">    connect_errno = socket_errno();</span><br><span class="line">  <span class="comment">/* 这被视为发送探测，因此更新结构 */</span></span><br><span class="line">  hss-&gt;probes_outstanding.push_back(probe);</span><br><span class="line">  probeI = hss-&gt;probes_outstanding.end();</span><br><span class="line">  probeI--;</span><br><span class="line">  USI-&gt;gstats-&gt;num_probes_active++;</span><br><span class="line">  hss-&gt;num_probes_active++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果connect()调用永远不会成功或永久失败，这将很方便，因此相关代码可以放在其他地方。</span></span><br><span class="line"><span class="comment">  	 但现实是，connect()现在可能已经完成。 */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rc == <span class="number">-1</span> &amp;&amp; (connect_errno == EINPROGRESS || connect_errno == EAGAIN)) &#123;</span><br><span class="line">    PacketTrace::traceConnect(IPPROTO_TCP, (sockaddr *) &amp;sock, socklen, rc,</span><br><span class="line">        connect_errno, &amp;USI-&gt;now);</span><br><span class="line">    USI-&gt;gstats-&gt;CSI-&gt;watchSD(CP-&gt;sd);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handleConnectResult(USI, hss, probeI, connect_errno, <span class="literal">true</span>);</span><br><span class="line">    probe = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  gettimeofday(&amp;USI-&gt;now, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> probe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进上面的<code>  rc = connect(CP-&gt;sd, (struct sockaddr *)&amp;sock, socklen);</code>，这里的<code>connect()</code>函数来自<code>WinSock2.h</code>，<code>WinSock2.h</code>是Windows操作系统中用于网络编程的头文件之一。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connect函数接收以下参数：</span><br><span class="line"></span><br><span class="line">1.s：这是一个套接字句柄（SOCKET），表示要进行连接操作的套接字。它是一个已经创建并绑定的套接字，可以是客户端套接字或服务器套接字。</span><br><span class="line">2.name：这是一个指向sockaddr结构体的指针。sockaddr结构体用于存储套接字地址信息，它可以是IPv4或IPv6地址。name参数指定要连接的目标地址，即要连接到的远程主机的IP地址和端口号。</span><br><span class="line">3.namelen：这是一个整数，表示name参数的字节长度。它指定了name指针所指向的sockaddr结构体的大小。</span><br></pre></td></tr></table></figure>

<p>我们来写一段代码来测试这里的<code>connect()</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)  <span class="comment">//// 链接到ws2_32.lib库</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;server_ip&gt; &lt;port_range&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* serverIP = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* portRange = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化Winsock库</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="keyword">if</span> (WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to initialize Winsock.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    SOCKET clientSocket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (clientSocket == INVALID_SOCKET) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to create socket.\n&quot;</span>);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置服务器地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddress</span>;</span></span><br><span class="line">    serverAddress.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, serverIP, &amp;(serverAddress.sin_addr)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid server IP address.\n&quot;</span>);</span><br><span class="line">        closesocket(clientSocket);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析端口范围参数</span></span><br><span class="line">    <span class="type">int</span> startPort, endPort;</span><br><span class="line">    sscanf_s(portRange, <span class="string">&quot;%d-%d&quot;</span>, &amp;startPort, &amp;endPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环扫描端口范围内的每个端口，并尝试连接到服务器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> port = startPort; port &lt;= endPort; ++port) &#123;</span><br><span class="line">        serverAddress.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (connect(clientSocket, (<span class="keyword">struct</span> sockaddr*)&amp;serverAddress, <span class="keyword">sizeof</span>(serverAddress)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Port %d is open.\n&quot;</span>, port);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Port %d is not open!!!\n&quot;</span>, port);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭套接字和清理Winsock库</span></span><br><span class="line">    closesocket(clientSocket);</span><br><span class="line">    WSACleanup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译生成exe，使用方法：<code>Test.exe 127.0.0.1 1-100</code> 扫描127.0.0.1的1-100端口<br>可以看到，扫描速度较慢，正因为TCP的可靠性，所以当端口不存在的时候，源主机会不断尝试发SYN帧企图得到ack的应答，多次尝试后才会放弃，因此造成了扫描的时间较长。<br>这里贴一个TCP握手的图片</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202311032013649.png" alt="image-20231103201308522"></p>
<p>返回上面的<code>sendPingProbe()</code>函数，继续看<code>sendIPScanProbe(USI, hss, pingprobe, tryno);//发送IP层扫描探测</code><br>根据不同的扫描类型，构建不同的扫描数据包<br>代码有点长，这里只贴出比较关键的一部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   ...</span><br><span class="line"><span class="keyword">if</span> (hss-&gt;target-&gt;af() == AF_INET) &#123;</span><br><span class="line">     <span class="keyword">for</span> (decoy = <span class="number">0</span>; decoy &lt; o.numdecoys; decoy++) &#123;</span><br><span class="line">       packet = build_tcp_raw(&amp;((<span class="keyword">struct</span> sockaddr_in *)&amp;o.decoys[decoy])-&gt;sin_addr, hss-&gt;target-&gt;v4hostip(),</span><br><span class="line">                              o.ttl, ipid, IP_TOS_DEFAULT, <span class="literal">false</span>,</span><br><span class="line">                              o.ipoptions, o.ipoptionslen,</span><br><span class="line">                              sport, pspec-&gt;pd.tcp.dport,</span><br><span class="line">                              seq, ack, <span class="number">0</span>, pspec-&gt;pd.tcp.flags, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                              tcpops, tcpopslen,</span><br><span class="line">                              o.extra_payload, o.extra_payload_length,</span><br><span class="line">                              &amp;packetlen);   <span class="comment">//构建 TCP 原始数据包</span></span><br><span class="line">       <span class="keyword">if</span> (decoy == o.decoyturn) &#123;</span><br><span class="line">         probe-&gt;setIP(packet, packetlen, pspec);<span class="comment">//设置 probe 对象的 IP 数据包信息，包括数据包内容和长度，以及与之相关的 pspec 参数</span></span><br><span class="line">         probe-&gt;sent = USI-&gt;now;</span><br><span class="line">       &#125;</span><br><span class="line">       hss-&gt;probeSent(packetlen);</span><br><span class="line">       send_ip_packet(USI-&gt;rawsd, ethptr, hss-&gt;target-&gt;TargetSockAddr(), packet, packetlen);<span class="comment">//发送 IP 数据包</span></span><br><span class="line">       <span class="built_in">free</span>(packet);  <span class="comment">//释放之前动态分配的数据包内存</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125; </span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>这里<code>build_tcp_raw()</code>函数的功能就是构建数据包，在上面的完整代码中有许多和他类似的函数，看一下他的具体实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">u8 *<span class="title function_">build_tcp_raw</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> in_addr *source,</span></span><br><span class="line"><span class="params">                  <span class="type">const</span> <span class="keyword">struct</span> in_addr *victim, <span class="type">int</span> ttl, u16 ipid, u8 tos,</span></span><br><span class="line"><span class="params">                  <span class="type">bool</span> df, <span class="type">const</span> u8 *ipopt, <span class="type">int</span> ipoptlen, u16 sport, u16 dport,</span></span><br><span class="line"><span class="params">                  u32 seq, u32 ack, u8 reserved, u8 flags, u16 window,</span></span><br><span class="line"><span class="params">                  u16 urp, <span class="type">const</span> u8 *tcpopt, <span class="type">int</span> tcpoptlen, <span class="type">const</span> <span class="type">char</span> *data,</span></span><br><span class="line"><span class="params">                  u16 datalen, u32 *packetlen)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_hdr</span> *<span class="title">tcp</span>;</span></span><br><span class="line">  u32 tcplen;</span><br><span class="line">  u8 *ip;</span><br><span class="line"></span><br><span class="line">  tcp = (<span class="keyword">struct</span> tcp_hdr *) build_tcp(sport, dport, seq, ack, reserved, flags,</span><br><span class="line">                                     window, urp, tcpopt, tcpoptlen, data, datalen, &amp;tcplen);<span class="comment">//构建 TCP 数据包</span></span><br><span class="line">  tcp-&gt;th_sum = ipv4_cksum(source, victim, IPPROTO_TCP, tcp, tcplen);<span class="comment">//计算 TCP 校验和，并将结果存储在 TCP 头部的 th_sum 字段中</span></span><br><span class="line">  ip = build_ip_raw(source, victim, IPPROTO_TCP, ttl, ipid, tos, df,</span><br><span class="line">                    ipopt, ipoptlen, (<span class="type">char</span> *) tcp, tcplen, packetlen);<span class="comment">//构建 IP 数据包</span></span><br><span class="line">  <span class="built_in">free</span>(tcp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<br><code>build_tcp()</code>：用于构建TCP报文的函数，根据给定的参数生成一个完整的TCP报文，用于在网络通信中发送和接收数据</p>
<p><code>ipv4_cksum()</code>：用于计算IPv4报文校验和的函数。校验和是用于验证数据在传输过程中是否发生了错误或损坏的一种机制。通过对IPv4数据报和相关信息进行计算，该函数返回一个16位的校验和值。</p>
<p><code>build_ip_raw()</code>：由应用程序直接构建的IP报文，用于实现更底层的网络通信。函数根据给定的参数构建一个完整的原始IP报文，并返回一个指向构建的报文的指针</p>
<p>在<code>sendIPScanProbe()</code>函数中，还有以下函数，功能和上面的类似</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">build_tcp_raw_ipv6()</span><br><span class="line">build_udp_raw()</span><br><span class="line">build_udp_raw_ipv6()</span><br><span class="line">build_sctp_raw()</span><br><span class="line">build_sctp_raw_ipv6()</span><br><span class="line">build_icmp_raw()</span><br><span class="line">build_icmpv6_raw()</span><br></pre></td></tr></table></figure>

<p>可以发送各种类型的报文</p>
<p>再看<code>sendPingProbe()</code>中的<code>sendArpScanProbe(USI, hss, tryno);//发送ARP扫描探测</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">UltraProbe *<span class="title function_">sendArpScanProbe</span><span class="params">(UltraScanInfo *USI, HostScanStats *hss,</span></span><br><span class="line"><span class="params">                             <span class="type">tryno_t</span> tryno)</span> &#123;</span><br><span class="line">  <span class="type">int</span> rc;</span><br><span class="line">  UltraProbe *probe = new UltraProbe();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 3 cheers for libdnet header files */</span></span><br><span class="line">  u8 frame[ETH_HDR_LEN + ARP_HDR_LEN + ARP_ETHIP_LEN]; <span class="comment">//用于存储构建的ARP扫描探测包的原始数据</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用以太网帧的目的MAC地址为广播地址，源MAC地址为hss-&gt;target-&gt;SrcMACAddress()，以太网类型为ARP，填充frame数组的前14个字节，构建以太网帧头部</span></span><br><span class="line">  eth_pack_hdr(frame, ETH_ADDR_BROADCAST, *hss-&gt;target-&gt;SrcMACAddress(),</span><br><span class="line">               ETH_TYPE_ARP);</span><br><span class="line">  <span class="comment">//使用ARP协议类型为请求(request)，源MAC地址为hss-&gt;target-&gt;SrcMACAddress()，源IP地址为hss-&gt;target-&gt;v4sourceip()，目的MAC地址为全0(&quot;\x00\x00\x00\x00\x00\x00&quot;)，目的IP地址为hss-&gt;target-&gt;v4hostip()，填充frame数组的后面的部分，构建ARP头部和IP地址部分</span></span><br><span class="line">  arp_pack_hdr_ethip(frame + ETH_HDR_LEN, ARP_OP_REQUEST,</span><br><span class="line">                     *hss-&gt;target-&gt;SrcMACAddress(), *hss-&gt;target-&gt;v4sourceip(),</span><br><span class="line">                     <span class="string">&quot;\x00\x00\x00\x00\x00\x00&quot;</span>,  *hss-&gt;target-&gt;v4hostip());</span><br><span class="line"><span class="comment">// RFC 826 指出 ar$tha 字段不需要设置任何特定的值（即它的值无关紧要）</span></span><br><span class="line"><span class="comment">// 我们使用00:00:00:00:00:00，因为这是当前流行操作系统中的IP栈所使用的。</span></span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;USI-&gt;now, <span class="literal">NULL</span>);</span><br><span class="line">  probe-&gt;sent = USI-&gt;now;</span><br><span class="line">  hss-&gt;probeSent(<span class="keyword">sizeof</span>(frame));</span><br><span class="line">  <span class="keyword">if</span> ((rc = eth_send(USI-&gt;ethsd, frame, <span class="keyword">sizeof</span>(frame))) != <span class="keyword">sizeof</span>(frame)) &#123; <span class="comment">//发送构建的ARP包</span></span><br><span class="line">    <span class="type">int</span> err = socket_errno();</span><br><span class="line">    error(<span class="string">&quot;WARNING: eth_send of ARP packet returned %i rather than expected %d (errno=%i: %s)&quot;</span>, rc, (<span class="type">int</span>) <span class="keyword">sizeof</span>(frame), err, strerror(err));</span><br><span class="line">  &#125;</span><br><span class="line">  PacketTrace::traceArp(PacketTrace::SENT, (u8 *) frame + ETH_HDR_LEN, <span class="keyword">sizeof</span>(frame) - ETH_HDR_LEN, &amp;USI-&gt;now);</span><br><span class="line">  probe-&gt;tryno = tryno;</span><br><span class="line">  <span class="comment">/* First build the probe */</span></span><br><span class="line">  probe-&gt;setARP(frame, <span class="keyword">sizeof</span>(frame));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 既然已发送探测，请将其添加到此主机的队列中 */</span></span><br><span class="line">  hss-&gt;probes_outstanding.push_back(probe);</span><br><span class="line">  USI-&gt;gstats-&gt;num_probes_active++;</span><br><span class="line">  hss-&gt;num_probes_active++;</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;USI-&gt;now, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> probe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的功能是构建并发送ARP扫描探测包，并将发送的探测包添加到主机的队列中以进行后续处理</p>
<p>继续看<code>sendNDScanProbe(USI, hss, tryno);//发送ND扫描探测</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">UltraProbe *<span class="title function_">sendNDScanProbe</span><span class="params">(UltraScanInfo *USI, HostScanStats *hss,</span></span><br><span class="line"><span class="params">                            <span class="type">tryno_t</span> tryno)</span> &#123;</span><br><span class="line">  UltraProbe *probe = new UltraProbe();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">eth_nfo</span> <span class="title">eth</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">eth_nfo</span> *<span class="title">ethptr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  u8 *packet = <span class="literal">NULL</span>;</span><br><span class="line">  u32 packetlen = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">ns_dst_ip6</span>;</span></span><br><span class="line">  ns_dst_ip6 = *hss-&gt;target-&gt;v6hostip(); <span class="comment">//将目标IPv6地址复制给ns_dst_ip6</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (USI-&gt;ethsd) &#123;  <span class="comment">//如果存在ethsd（以太网套接字描述符）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ns_dst_mac[<span class="number">6</span>] = &#123;<span class="number">0x33</span>, <span class="number">0x33</span>, <span class="number">0xff</span>&#125;; <span class="comment">//创建一个用于IPv6多播的目标MAC地址</span></span><br><span class="line">    ns_dst_mac[<span class="number">3</span>] = ns_dst_ip6.s6_addr[<span class="number">13</span>];</span><br><span class="line">    ns_dst_mac[<span class="number">4</span>] = ns_dst_ip6.s6_addr[<span class="number">14</span>];</span><br><span class="line">    ns_dst_mac[<span class="number">5</span>] = ns_dst_ip6.s6_addr[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将源MAC地址和目标MAC地址复制给eth结构体</span></span><br><span class="line">    <span class="built_in">memcpy</span>(eth.srcmac, hss-&gt;target-&gt;SrcMACAddress(), <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(eth.dstmac, ns_dst_mac, <span class="number">6</span>);</span><br><span class="line">    eth.ethsd = USI-&gt;ethsd;</span><br><span class="line">    eth.devname[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    ethptr = &amp;eth;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//创建IPv6多播地址前缀</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> multicast_prefix[<span class="number">13</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  multicast_prefix[<span class="number">0</span>] = <span class="number">0xff</span>;</span><br><span class="line">  multicast_prefix[<span class="number">1</span>] = <span class="number">0x02</span>;</span><br><span class="line">  multicast_prefix[<span class="number">11</span>] = <span class="number">0x1</span>;</span><br><span class="line">  multicast_prefix[<span class="number">12</span>] = <span class="number">0xff</span>;</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;ns_dst_ip6, multicast_prefix, <span class="keyword">sizeof</span>(multicast_prefix));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//获取源套接字地址的IPv6信息</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> *<span class="title">sin6</span> =</span> (<span class="keyword">struct</span> sockaddr_in6 *) USI-&gt;SourceSockAddr();</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">icmpv6_msg_nd</span> <span class="title">ns_msg</span>;</span></span><br><span class="line">  ns_msg.icmpv6_flags = htons(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;ns_msg.icmpv6_target, hss-&gt;target-&gt;v6hostip(), IP6_ADDR_LEN);</span><br><span class="line">  ns_msg.icmpv6_option_type = <span class="number">1</span>;</span><br><span class="line">  ns_msg.icmpv6_option_length = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;ns_msg.icmpv6_mac, hss-&gt;target-&gt;SrcMACAddress(), ETH_ADDR_LEN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构建ICMPv6原始数据包</span></span><br><span class="line">  packet = build_icmpv6_raw(&amp;sin6-&gt;sin6_addr, &amp;ns_dst_ip6,</span><br><span class="line">                            <span class="number">0</span>, <span class="number">0</span>, o.ttl, <span class="number">0</span>, <span class="number">0</span>, ICMPV6_NEIGHBOR_SOLICITATION,</span><br><span class="line">                            <span class="number">0</span>, (<span class="type">char</span> *)&amp;ns_msg, <span class="keyword">sizeof</span>(ns_msg),</span><br><span class="line">                            &amp;packetlen);</span><br><span class="line">  probe-&gt;sent = USI-&gt;now;  <span class="comment">//设置probe的发送时间</span></span><br><span class="line">  hss-&gt;probeSent(packetlen);</span><br><span class="line">  send_ip_packet(USI-&gt;rawsd, ethptr, hss-&gt;target-&gt;TargetSockAddr(), packet, packetlen);<span class="comment">//发送IP数据包</span></span><br><span class="line"></span><br><span class="line">  probe-&gt;tryno = tryno;</span><br><span class="line">  <span class="comment">/* 首先构建探测器 */</span></span><br><span class="line">  probe-&gt;setND(packet, packetlen);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(packet);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 既然探测已经发送，请将其添加到此主机的队列中 */</span></span><br><span class="line">  hss-&gt;probes_outstanding.push_back(probe);</span><br><span class="line">  USI-&gt;gstats-&gt;num_probes_active++;</span><br><span class="line">  hss-&gt;num_probes_active++;</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;USI-&gt;now, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> probe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的作用是发送IPv6邻居发现探测包<br>补充：邻居发现协议NDP（Neighbor Discovery Protocol）是IPv6协议体系中一个重要的基础协议。邻居发现协议替代了IPv4的ARP（Address Resolution Protocol）和ICMP路由器发现（Router Discovery），它定义了使用ICMPv6报文实现地址解析，跟踪邻居状态，重复地址检测，路由器发现以及重定向等功能。</p>
<p>我们返回<code>doAnyPings()</code>函数，继续看<code>sendGlobalPingProbe(USI);   //调用sendGlobalPingProbe函数发送全球ping探测</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sendGlobalPingProbe</span><span class="params">(UltraScanInfo *USI)</span> &#123;</span><br><span class="line">  HostScanStats *hss;</span><br><span class="line"></span><br><span class="line">  hss = USI-&gt;gstats-&gt;pinghost;</span><br><span class="line">  assert(hss != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (o.debugging &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">char</span> tmpbuf[<span class="number">64</span>];</span><br><span class="line">    log_write(LOG_PLAIN, <span class="string">&quot;Ultrascan GLOBAL PING SENT to %s [%s]\n&quot;</span>, hss-&gt;target-&gt;targetipstr(),</span><br><span class="line">              probespec2ascii(&amp;hss-&gt;target-&gt;pingprobe, tmpbuf, <span class="keyword">sizeof</span>(tmpbuf)));</span><br><span class="line">  &#125;</span><br><span class="line">  sendPingProbe(USI, hss);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进<code>sendPingProbe(USI, hss);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sendPingProbe</span><span class="params">(UltraScanInfo *USI, HostScanStats *hss)</span> &#123;</span><br><span class="line">  <span class="type">tryno_t</span> tryno = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  tryno.fields.isPing = <span class="number">1</span>;</span><br><span class="line">  tryno.fields.seqnum = hss-&gt;nextPingSeq();</span><br><span class="line"></span><br><span class="line">  probespec *pingprobe = &amp;hss-&gt;target-&gt;pingprobe;</span><br><span class="line">  <span class="keyword">switch</span> (pingprobe-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> PS_CONNECTTCP:</span><br><span class="line">      sendConnectScanProbe(USI, hss, pingprobe-&gt;pd.tcp.dport, tryno);<span class="comment">//发送连接式TCP扫描探测</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PS_TCP:</span><br><span class="line">    <span class="keyword">case</span> PS_UDP:</span><br><span class="line">    <span class="keyword">case</span> PS_SCTP:</span><br><span class="line">    <span class="keyword">case</span> PS_PROTO:</span><br><span class="line">    <span class="keyword">case</span> PS_ICMP:</span><br><span class="line">      sendIPScanProbe(USI, hss, pingprobe, tryno);<span class="comment">//发送IP层扫描探测</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PS_ARP:</span><br><span class="line">      sendArpScanProbe(USI, hss, tryno);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PS_ND:</span><br><span class="line">      sendNDScanProbe(USI, hss, tryno); <span class="comment">//发送ARP扫描探测</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      assert(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (o.debugging &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">char</span> tmpbuf[<span class="number">64</span>];</span><br><span class="line">    log_write(LOG_PLAIN, <span class="string">&quot;Ultrascan PING SENT to %s [%s]\n&quot;</span>, hss-&gt;target-&gt;targetipstr(),</span><br><span class="line">              probespec2ascii(pingprobe, tmpbuf, <span class="keyword">sizeof</span>(tmpbuf)));</span><br><span class="line">  &#125;</span><br><span class="line">  USI-&gt;gstats-&gt;probes_sent++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码结构和<code>sendPingProbe(USI, hss);</code>很相似，调用的函数也是一样的，就是参数不同。</p>
<p>现在回到<code>nmap_main()</code>继续往下看：<br><code>idle_scan()</code>：空闲扫描<br>空闲扫描允许进行端口完全欺骗扫描，可以使攻击者能够不使用自己的IP向目标主机发送数据包，它可以利用不活跃的僵尸主机反弹给攻击者一个通道，从而进行端口扫描。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">idle_scan</span><span class="params">(Target *target, u16 *portarray, <span class="type">int</span> numports,</span></span><br><span class="line"><span class="params">               <span class="type">char</span> *proxyName, <span class="type">const</span> <span class="keyword">struct</span> scan_lists *ports)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> lastproxy[FQDN_LEN + <span class="number">1</span>] = <span class="string">&quot;&quot;</span>; <span class="comment">/* 以前任何调用中使用的代理 */</span></span><br><span class="line">  <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">idle_proxy_info</span> <span class="title">proxy</span>;</span></span><br><span class="line">  <span class="type">int</span> groupsz;</span><br><span class="line">  <span class="type">int</span> portidx = <span class="number">0</span>; <span class="comment">/* 用于将端口阵列拆分为块 */</span></span><br><span class="line">  <span class="type">int</span> portsleft;</span><br><span class="line">  <span class="type">char</span> scanname[<span class="number">128</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//将扫描名称格式化为字符串，并将其传递给ScanProgressMeter类的构造函数，创建一个扫描进度计量器对象SPM</span></span><br><span class="line">  Snprintf(scanname, <span class="keyword">sizeof</span>(scanname), <span class="string">&quot;idle scan against %s&quot;</span>, target-&gt;NameIP());</span><br><span class="line">  ScanProgressMeter <span class="title function_">SPM</span><span class="params">(scanname)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (numports == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* nothing to scan for */</span></span><br><span class="line">  <span class="keyword">if</span> (!proxyName)</span><br><span class="line">    fatal(<span class="string">&quot;idle scan requires a proxy host&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*lastproxy &amp;&amp; <span class="built_in">strcmp</span>(proxyName, lastproxy))</span><br><span class="line">    fatal(<span class="string">&quot;%s: You are not allowed to change proxies midstream.  Sorry&quot;</span>, __func__);</span><br><span class="line">  assert(target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (target-&gt;timedOut(<span class="literal">NULL</span>))  <span class="comment">//如果目标已经超时，则直接返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果目标的接口类型是devt_loopback，即回环接口（localhost），则输出日志并返回</span></span><br><span class="line">  <span class="keyword">if</span> (target-&gt;ifType() == devt_loopback) &#123;</span><br><span class="line">    log_write(LOG_STDOUT, <span class="string">&quot;Skipping Idle Scan against %s -- you can&#x27;t idle scan your own machine (localhost).\n&quot;</span>, target-&gt;NameIP());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  target-&gt;startTimeOutClock(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果这是第一次请求，  */</span></span><br><span class="line">  <span class="keyword">if</span> (!*lastproxy) &#123;</span><br><span class="line">    initialize_idleproxy(&amp;proxy, proxyName, target, ports);</span><br><span class="line">    <span class="built_in">strncpy</span>(lastproxy, proxyName, <span class="keyword">sizeof</span>(lastproxy));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果我们没有新目标的时间信息，我们将使用从代理导出的值 */</span></span><br><span class="line">  <span class="keyword">if</span> (target-&gt;to.srtt == <span class="number">-1</span> &amp;&amp; target-&gt;to.rttvar == <span class="number">-1</span>) &#123;</span><br><span class="line">    target-&gt;to.srtt = MAX(<span class="number">200000</span>, <span class="number">2</span> * proxy.host.to.srtt);</span><br><span class="line">    target-&gt;to.rttvar = MAX(<span class="number">10000</span>, MIN(proxy.host.to.rttvar, <span class="number">2000000</span>));</span><br><span class="line">    target-&gt;to.timeout = target-&gt;to.srtt + (target-&gt;to.rttvar &lt;&lt; <span class="number">2</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    target-&gt;to.srtt = MAX(target-&gt;to.srtt, proxy.host.to.srtt);</span><br><span class="line">    target-&gt;to.rttvar = MAX(target-&gt;to.rttvar, proxy.host.to.rttvar);</span><br><span class="line">    target-&gt;to.timeout = target-&gt;to.srtt + (target-&gt;to.rttvar &lt;&lt; <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 现在我想是时候开始扫描了！由于空闲扫描有点树形结构（我们扫描一个组，</span></span><br><span class="line"><span class="comment">     然后将其分割并深入到该组的子扫描中），我们将端口空间分成更小的组，</span></span><br><span class="line"><span class="comment">     然后调用递归的分割和征服函数来查找开放端口 */</span></span><br><span class="line">  <span class="comment">//使用循环进行端口扫描，将端口数组分成更小的组，并调用idle_treescan函数对每个组进行扫描</span></span><br><span class="line">  <span class="keyword">while</span> (portidx &lt; numports) &#123;</span><br><span class="line">    portsleft = numports - portidx;</span><br><span class="line">    <span class="comment">/* 由于 idle_subscan 减半，因此 current_groupsz 以下加倍 */</span></span><br><span class="line">    groupsz = MIN(portsleft, (<span class="type">int</span>) (proxy.current_groupsz * <span class="number">2</span>));</span><br><span class="line">    idle_treescan(&amp;proxy, target, portarray + portidx, groupsz, <span class="number">-1</span>);</span><br><span class="line">    portidx += groupsz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用Snprintf函数将附加信息格式化为字符串，并调用SPM.endTask函数结束任务，将附加信息传递给扫描进度计量器对象</span></span><br><span class="line">  <span class="type">char</span> additional_info[<span class="number">14</span>];</span><br><span class="line">  Snprintf(additional_info, <span class="keyword">sizeof</span>(additional_info), <span class="string">&quot;%d ports&quot;</span>, numports);</span><br><span class="line">  SPM.endTask(<span class="literal">NULL</span>, additional_info);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 现在我们遍历被扫描但未确定为开放的端口，并将其添加到“closed|filtered”状态 */</span></span><br><span class="line">  <span class="keyword">for</span> (portidx = <span class="number">0</span>; portidx &lt; numports; portidx++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target-&gt;ports.portIsDefault(portarray[portidx], IPPROTO_TCP)) &#123;</span><br><span class="line">      target-&gt;ports.setPortState(portarray[portidx], IPPROTO_TCP, PORT_CLOSEDFILTERED);</span><br><span class="line">      target-&gt;ports.setStateReason(portarray[portidx], IPPROTO_TCP, ER_NOIPIDCHANGE, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target-&gt;ports.setStateReason(portarray[portidx], IPPROTO_TCP, ER_IPIDCHANGE, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  target-&gt;stopTimeOutClock(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>继续看<code>nmap_main()</code>的<code>bounce_scan()</code>：FTP弹跳扫描<br>它允许用户连接连接到一台FTP服务器，然后要求文件送到一台第三方服务器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bounce_scan</span><span class="params">(Target *target, u16 *portarray, <span class="type">int</span> numports,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> ftpinfo *ftp)</span> &#123;</span><br><span class="line">  o.current_scantype = BOUNCE_SCAN;</span><br><span class="line"></span><br><span class="line">  ScanProgressMeter *SPM;</span><br><span class="line">  <span class="type">int</span> res , sd = ftp-&gt;sd,  i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *t = (<span class="type">const</span> <span class="type">char</span> *)target-&gt;v4hostip();</span><br><span class="line">  <span class="type">int</span> retriesleft = FTP_RETRIES;</span><br><span class="line">  <span class="type">char</span> recvbuf[<span class="number">2048</span>];</span><br><span class="line">  <span class="type">char</span> targetstr[<span class="number">20</span>];</span><br><span class="line">  <span class="type">char</span> command[<span class="number">512</span>];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> portno, p1, p2;</span><br><span class="line">  <span class="type">int</span> timedout;</span><br><span class="line">  <span class="type">bool</span> privok = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (numports == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* nothing to scan for */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将目标IP地址格式化为字符串形式并存储在targetstr中</span></span><br><span class="line">  Snprintf(targetstr, <span class="number">20</span>, <span class="string">&quot;%d,%d,%d,%d,&quot;</span>, UC(t[<span class="number">0</span>]), UC(t[<span class="number">1</span>]), UC(t[<span class="number">2</span>]), UC(t[<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line">  SPM = new ScanProgressMeter(scantype2str(BOUNCE_SCAN));</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numports; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for timeout */</span></span><br><span class="line">    <span class="keyword">if</span> (target-&gt;timedOut(<span class="literal">NULL</span>)) &#123; <span class="comment">// 检查目标是否超时</span></span><br><span class="line">      Snprintf(recvbuf, <span class="keyword">sizeof</span>(recvbuf), <span class="string">&quot;Target timed out&quot;</span>);</span><br><span class="line">      SPM-&gt;endTask(<span class="literal">NULL</span>, recvbuf);</span><br><span class="line">      delete SPM;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    portno = htons(portarray[i]);          <span class="comment">// 将端口号转换为网络字节序</span></span><br><span class="line">    p1 = ((<span class="type">unsigned</span> <span class="type">char</span> *) &amp;portno)[<span class="number">0</span>];   <span class="comment">// 获取端口号的高字节</span></span><br><span class="line">    p2 = ((<span class="type">unsigned</span> <span class="type">char</span> *) &amp;portno)[<span class="number">1</span>];   <span class="comment">// 获取端口号的低字节</span></span><br><span class="line">    Snprintf(command, <span class="number">512</span>, <span class="string">&quot;PORT %s%i,%i\r\n&quot;</span>, targetstr, p1, p2);</span><br><span class="line">    <span class="keyword">if</span> (o.debugging)</span><br><span class="line">      log_write(LOG_STDOUT, <span class="string">&quot;Attempting command: %s&quot;</span>, command);</span><br><span class="line">    <span class="keyword">if</span> (send(sd, command, <span class="built_in">strlen</span>(command), <span class="number">0</span>) &lt; <span class="number">0</span> ) &#123;   <span class="comment">// 发送命令（核心）</span></span><br><span class="line">      gh_perror(<span class="string">&quot;send in %s&quot;</span>, __func__);                <span class="comment">// 发送失败时输出错误信息</span></span><br><span class="line">      <span class="keyword">if</span> (retriesleft) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o.verbose || o.debugging)</span><br><span class="line">          log_write(LOG_STDOUT, <span class="string">&quot;Our FTP proxy server hung up on us!  retrying\n&quot;</span>);</span><br><span class="line">        retriesleft--;</span><br><span class="line">        close(sd);</span><br><span class="line">        ftp-&gt;sd = ftp_anon_connect(ftp);   <span class="comment">// 重新连接FTP服务器</span></span><br><span class="line">        <span class="keyword">if</span> (ftp-&gt;sd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          Snprintf(recvbuf, <span class="keyword">sizeof</span>(recvbuf), <span class="string">&quot;Error connecting&quot;</span>);</span><br><span class="line">          SPM-&gt;endTask(<span class="literal">NULL</span>, recvbuf);</span><br><span class="line">          delete SPM;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sd = ftp-&gt;sd;</span><br><span class="line">        i--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        error(<span class="string">&quot;Our socket descriptor is dead and we are out of retries. Giving up.&quot;</span>);</span><br><span class="line">        close(sd);</span><br><span class="line">        ftp-&gt;sd = <span class="number">-1</span>;</span><br><span class="line">        Snprintf(recvbuf, <span class="keyword">sizeof</span>(recvbuf), <span class="string">&quot;Max retries exceeded&quot;</span>);</span><br><span class="line">        SPM-&gt;endTask(<span class="literal">NULL</span>, recvbuf);</span><br><span class="line">        delete SPM;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* Our send is good */</span></span><br><span class="line">      res = recvtime(sd, recvbuf, <span class="number">2048</span>, <span class="number">15</span>, <span class="literal">NULL</span>);  <span class="comment">//从FTP弹跳服务器接收数据</span></span><br><span class="line">      <span class="keyword">if</span> (res &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;recv problem from FTP bounce server&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">/* our recv is good */</span></span><br><span class="line">        recvbuf[res] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (o.debugging)</span><br><span class="line">          log_write(LOG_STDOUT, <span class="string">&quot;result of port query on port %i: %s&quot;</span>,</span><br><span class="line">                                     portarray[i],  recvbuf);</span><br><span class="line">        <span class="keyword">if</span> (recvbuf[<span class="number">0</span>] == <span class="string">&#x27;5&#x27;</span> &amp;&amp; !privok) &#123;</span><br><span class="line">          <span class="keyword">if</span> (portarray[i] &gt; <span class="number">1023</span>) &#123; <span class="comment">//如果当前端口号大于1023，表示FTP弹跳服务器不接受特权端口，将触发致命错误</span></span><br><span class="line">            fatal(<span class="string">&quot;Your FTP bounce server sucks, it won&#x27;t let us feed bogus ports!&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            error(<span class="string">&quot;Your FTP bounce server doesn&#x27;t allow privileged ports, skipping them.&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (i &lt; numports &amp;&amp; portarray[i] &lt; <span class="number">1024</span>) i++;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= numports) &#123;</span><br><span class="line">              fatal(<span class="string">&quot;And you didn&#x27;t want to scan any unprivileged ports.  Giving up.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>该函数的作用是通过FTP代理服务器执行端口扫描操作，并处理连接失败和超时等情况。它使用FTP的PORT命令来指定数据连接的端口，以便进行端口扫描。上面的代码中，发送命令到一个FTP服务器。具体发送的命令是通过格式化字符串<code>command</code>生成的，格式为<code>&quot;PORT %s%i,%i\r\n&quot;</code>。其中，<code>%s</code>表示目标IP地址字符串，<code>%i</code>表示端口号的高字节，再后面的<code>%i</code>表示端口号的低字节。因此，实际发送的命令是以目标IP地址和端口号构成的<code>PORT</code>命令，用于告诉FTP服务器客户端将使用指定的端口进行数据传输。</p>
<p>继续看<code>service_scan()</code>：服务扫描</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">service_scan</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt; &amp;Targets)</span> &#123;</span><br><span class="line">  <span class="comment">// int service_scan(Target *targets[], int num_targets)</span></span><br><span class="line">  AllProbes *AP;</span><br><span class="line">  ServiceGroup *SG;</span><br><span class="line">  nsock_pool nsp;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">  <span class="type">int</span> timeout;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">nsock_loopstatus</span> <span class="title">looprc</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">starttv</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Targets.size() == <span class="number">0</span>)  <span class="comment">//如果Targets向量为空，则返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  AP = AllProbes::service_scan_init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在我将目标转换为新的 ServiceGroup</span></span><br><span class="line">  SG = new ServiceGroup(Targets, AP);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (o.override_excludeports) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o.debugging || o.verbose) log_write(LOG_PLAIN, <span class="string">&quot;Overriding exclude ports option! Some undesirable ports may be version scanned!\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    remove_excluded_ports(AP, SG);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SG-&gt;services_remaining.size() == <span class="number">0</span>) &#123;   <span class="comment">//判断检查是否还有剩余的服务需要扫描</span></span><br><span class="line">    processResults(SG);</span><br><span class="line">    delete SG;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;starttv, <span class="literal">NULL</span>);  <span class="comment">//获取当前时间</span></span><br><span class="line">  <span class="keyword">if</span> (o.verbose) &#123;   <span class="comment">//输出扫描信息，包括要扫描的服务数量和目标主机的描述信息</span></span><br><span class="line">    <span class="type">char</span> targetstr[<span class="number">128</span>];</span><br><span class="line">    <span class="type">bool</span> plural = (Targets.size() != <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!plural) &#123;</span><br><span class="line">      (*(Targets.begin()))-&gt;NameIP(targetstr, <span class="keyword">sizeof</span>(targetstr));</span><br><span class="line">    &#125; <span class="keyword">else</span> Snprintf(targetstr, <span class="keyword">sizeof</span>(targetstr), <span class="string">&quot;%u hosts&quot;</span>, (<span class="type">unsigned</span>) Targets.size());</span><br><span class="line"></span><br><span class="line">    log_write(LOG_STDOUT, <span class="string">&quot;Scanning %u %s on %s\n&quot;</span>,</span><br><span class="line">              (<span class="type">unsigned</span>) SG-&gt;services_remaining.size(),</span><br><span class="line">              (SG-&gt;services_remaining.size() == <span class="number">1</span>)? <span class="string">&quot;service&quot;</span> : <span class="string">&quot;services&quot;</span>,</span><br><span class="line">              targetstr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 让我们创建一个nsock池来管理所有并发探测</span></span><br><span class="line">  <span class="comment">// 将服务组存储在那里，以便在回调中可用</span></span><br><span class="line">  <span class="keyword">if</span> ((nsp = nsock_pool_new(SG)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    fatal(<span class="string">&quot;%s() failed to create new nsock pool.&quot;</span>, __func__);</span><br><span class="line">  &#125;</span><br><span class="line">  nmap_set_nsock_logger();                    <span class="comment">//设置nsock的日志记录器，调整日志级别</span></span><br><span class="line">  nmap_adjust_loglevel(o.versionTrace());</span><br><span class="line"></span><br><span class="line">  nsock_pool_set_device(nsp, o.device);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (o.proxy_chain) &#123;</span><br><span class="line">    nsock_pool_set_proxychain(nsp, o.proxy_chain);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_OPENSSL</span></span><br><span class="line">  <span class="comment">/* 我们不关心版本检测中的连接安全性。 */</span></span><br><span class="line">  nsock_pool_ssl_init(nsp, NSOCK_SSL_MAX_SPEED);   <span class="comment">//使用OpenSSL库初始化nsp对象的SSL和DTLS</span></span><br><span class="line">  nsock_pool_dtls_init(nsp, NSOCK_SSL_MAX_SPEED);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  launchSomeServiceProbes(nsp, SG);  <span class="comment">//启动服务探测</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们还有多长时间？</span></span><br><span class="line">  gettimeofday(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">  timeout = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 好!啊让我们开始我们的主循环！</span></span><br><span class="line">  looprc = nsock_loop(nsp, timeout);</span><br><span class="line">  <span class="keyword">if</span> (looprc == NSOCK_LOOP_ERROR) &#123;</span><br><span class="line">    <span class="type">int</span> err = nsock_pool_get_error(nsp);</span><br><span class="line">    fatal(<span class="string">&quot;Unexpected nsock_loop error.  Error code %d (%s)&quot;</span>, err, socket_strerror(err));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nsock_pool_delete(nsp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (o.verbose) &#123;   <span class="comment">//根据扫描的结果输出额外的信息</span></span><br><span class="line">    <span class="type">char</span> additional_info[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">if</span> (SG-&gt;num_hosts_timedout == <span class="number">0</span>)</span><br><span class="line">      Snprintf(additional_info, <span class="keyword">sizeof</span>(additional_info), <span class="string">&quot;%u %s on %u %s&quot;</span>,</span><br><span class="line">                (<span class="type">unsigned</span>) SG-&gt;services_finished.size(),</span><br><span class="line">                (SG-&gt;services_finished.size() == <span class="number">1</span>)? <span class="string">&quot;service&quot;</span> : <span class="string">&quot;services&quot;</span>,</span><br><span class="line">                (<span class="type">unsigned</span>) Targets.size(), (Targets.size() == <span class="number">1</span>)? <span class="string">&quot;host&quot;</span> : <span class="string">&quot;hosts&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> Snprintf(additional_info, <span class="keyword">sizeof</span>(additional_info), <span class="string">&quot;%u %s timed out&quot;</span>,</span><br><span class="line">                   SG-&gt;num_hosts_timedout,</span><br><span class="line">                   (SG-&gt;num_hosts_timedout == <span class="number">1</span>)? <span class="string">&quot;host&quot;</span> : <span class="string">&quot;hosts&quot;</span>);</span><br><span class="line">    SG-&gt;SPM-&gt;endTask(<span class="literal">NULL</span>, additional_info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是的-服务扫描已经完成。现在我查看结果</span></span><br><span class="line">  <span class="comment">// 发现，将重要信息存储起来，并释放所有内容</span></span><br><span class="line">  <span class="comment">// else.</span></span><br><span class="line">  processResults(SG);</span><br><span class="line"></span><br><span class="line">  delete SG;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进<code>launchSomeServiceProbes(nsp, SG);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">launchSomeServiceProbes</span><span class="params">(nsock_pool nsp, ServiceGroup *SG)</span> &#123;</span><br><span class="line">  ServiceNFO *svc;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> warn_no_scanning=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (SG-&gt;services_in_progress.size() &lt; SG-&gt;ideal_parallelism &amp;&amp;</span><br><span class="line">         !SG-&gt;services_remaining.empty()) &#123;</span><br><span class="line">    <span class="comment">// 从新列表中开始执行探测，并将其移动到in_progress</span></span><br><span class="line">    svc = SG-&gt;services_remaining.front();   <span class="comment">//获取SG-&gt;services_remaining列表的第一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (svc-&gt;target-&gt;timedOut(nsock_gettimeofday())) &#123;     <span class="comment">//如果超时则结束探测</span></span><br><span class="line">      end_svcprobe(PROBESTATE_INCOMPLETE, SG, svc, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!svc-&gt;target-&gt;timeOutClockRunning()) &#123;</span><br><span class="line">      svc-&gt;target-&gt;startTimeOutClock(nsock_gettimeofday());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始！如果没有探测器，我们马上就会收到不匹配的信号。</span></span><br><span class="line">    startNextProbe(nsp, <span class="literal">NULL</span>, SG, svc, <span class="literal">true</span>);   <span class="comment">//启动探测任务</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (svc-&gt;probe_state == PROBESTATE_FINISHED_NOMATCH) &#123;</span><br><span class="line">      <span class="keyword">if</span> (warn_no_scanning &amp;&amp; o.debugging) &#123;</span><br><span class="line">        log_write(LOG_PLAIN, <span class="string">&quot;Service scan: Not probing some ports due to low intensity\n&quot;</span>);</span><br><span class="line">        warn_no_scanning=<span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查服务是否仍在我们离开的地方。</span></span><br><span class="line">    <span class="comment">// servicescan_connect_handler可以在此点之前调用end_svcprobe，</span></span><br><span class="line">    <span class="comment">// 已将其置于 services_finished 状态。</span></span><br><span class="line">    <span class="keyword">if</span> (!SG-&gt;services_remaining.empty() &amp;&amp; SG-&gt;services_remaining.front() == svc) &#123;</span><br><span class="line">      <span class="comment">// 现在将其从剩余的服务列表中删除</span></span><br><span class="line">      SG-&gt;services_remaining.pop_front();</span><br><span class="line">      <span class="comment">// 并将其添加到进行中列表中</span></span><br><span class="line">      SG-&gt;services_in_progress.push_back(svc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进<code>startNextProbe(nsp, NULL, SG, svc, true);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">startNextProbe</span><span class="params">(nsock_pool nsp, nsock_iod nsi, ServiceGroup *SG,</span></span><br><span class="line"><span class="params">                           ServiceNFO *svc, <span class="type">bool</span> alwaysrestart)</span> &#123;</span><br><span class="line">  <span class="type">bool</span> isInitial = svc-&gt;probe_state == PROBESTATE_INITIAL;</span><br><span class="line">  ServiceProbe *probe = svc-&gt;currentProbe(); <span class="comment">//获取当前探测</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span></span><br><span class="line">  <span class="type">size_t</span> ss_len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!alwaysrestart &amp;&amp; probe-&gt;isNullProbe()) &#123;</span><br><span class="line">    <span class="comment">// 这里的不同之处在于我们可以重用相同的（TCP）连接</span></span><br><span class="line">    <span class="comment">// 如果最后一个探测是空探测。</span></span><br><span class="line">    probe = svc-&gt;nextProbe(<span class="literal">false</span>); <span class="comment">//获取下一个探测</span></span><br><span class="line">    <span class="keyword">if</span> (probe) &#123;</span><br><span class="line">      svc-&gt;currentprobe_exec_time = *nsock_gettimeofday();</span><br><span class="line">      send_probe_text(nsp, nsi, svc, probe);  <span class="comment">//发送探测请求</span></span><br><span class="line">      nsock_read(nsp, nsi, servicescan_read_handler,</span><br><span class="line">                 svc-&gt;probe_timemsleft(probe, nsock_gettimeofday()), svc); <span class="comment">//读取响应</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 只有当某人拥有高度反常的nmap-service-probes文件时才会发生。零扫描通常不应是唯一的探测。</span></span><br><span class="line">      end_svcprobe((svc-&gt;softMatchFound)? PROBESTATE_FINISHED_SOFTMATCHED : PROBESTATE_FINISHED_NOMATCH, SG, svc, <span class="literal">NULL</span>); <span class="comment">//探测结束</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 完成的探测不是NULL探测。因此我们关闭连接，如果还有可用的探测，我们启动下一个。</span></span><br><span class="line">    <span class="keyword">if</span> (nsi)</span><br><span class="line">      nsock_iod_delete(nsi, NSOCK_PENDING_SILENT);  <span class="comment">//关闭连接</span></span><br><span class="line">    <span class="keyword">if</span> (!isInitial)</span><br><span class="line">      probe = svc-&gt;nextProbe(<span class="literal">true</span>); <span class="comment">// 如果为初始值，则 currentProbe() 返回正确的执行值。</span></span><br><span class="line">    <span class="keyword">if</span> (probe) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((svc-&gt;niod = nsock_iod_new(nsp, svc)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fatal(<span class="string">&quot;Failed to allocate Nsock I/O descriptor in %s()&quot;</span>, __func__);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (o.spoofsource) &#123;</span><br><span class="line">        o.SourceSockAddr(&amp;ss, &amp;ss_len);</span><br><span class="line">        nsock_iod_set_localaddr(svc-&gt;niod, &amp;ss, ss_len);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (o.ipoptionslen)</span><br><span class="line">        nsock_iod_set_ipoptions(svc-&gt;niod, o.ipoptions, o.ipoptionslen);</span><br><span class="line">      <span class="keyword">if</span> (svc-&gt;target-&gt;TargetName()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nsock_iod_set_hostname(svc-&gt;niod, svc-&gt;target-&gt;TargetName()) == <span class="number">-1</span>)</span><br><span class="line">          fatal(<span class="string">&quot;nsock_iod_set_hostname(\&quot;%s\&quot; failed in %s()&quot;</span>,</span><br><span class="line">                svc-&gt;target-&gt;TargetName(), __func__);</span><br><span class="line">      &#125;</span><br><span class="line">      svc-&gt;target-&gt;TargetSockAddr(&amp;ss, &amp;ss_len);</span><br><span class="line">      <span class="keyword">if</span> (svc-&gt;tunnel == SERVICE_TUNNEL_NONE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (svc-&gt;proto == IPPROTO_TCP) &#123;</span><br><span class="line">          nsock_connect_tcp(nsp, svc-&gt;niod, servicescan_connect_handler,</span><br><span class="line">                            DEFAULT_CONNECT_TIMEOUT, svc,</span><br><span class="line">                            (<span class="keyword">struct</span> sockaddr *) &amp;ss, ss_len,</span><br><span class="line">                            svc-&gt;portno);  <span class="comment">//连接TCP服务</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          nsock_connect_udp(nsp, svc-&gt;niod, servicescan_connect_handler,</span><br><span class="line">                            svc, (<span class="keyword">struct</span> sockaddr *) &amp;ss, ss_len,</span><br><span class="line">                            svc-&gt;portno); <span class="comment">//连接UDP服务</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(svc-&gt;tunnel == SERVICE_TUNNEL_SSL);</span><br><span class="line">        nsock_connect_ssl(nsp, svc-&gt;niod, servicescan_connect_handler,</span><br><span class="line">                          DEFAULT_CONNECT_SSL_TIMEOUT, svc,</span><br><span class="line">                          (<span class="keyword">struct</span> sockaddr *) &amp;ss,</span><br><span class="line">                          ss_len, svc-&gt;proto, svc-&gt;portno, svc-&gt;ssl_session); <span class="comment">//连接SSL服务</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有剩余探测！匹配失败</span></span><br><span class="line">      end_svcprobe((svc-&gt;softMatchFound)? PROBESTATE_FINISHED_SOFTMATCHED :</span><br><span class="line">                                               PROBESTATE_FINISHED_NOMATCH,</span><br><span class="line">                   SG, svc, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>继续看<code>nmap_main()</code>的<code>os_engine.os_scan()</code>：操作系统扫描</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">OSScan::os_scan</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt; &amp;Targets)</span> &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt; ip4_targets;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt; ip6_targets;</span><br><span class="line">  <span class="type">int</span> res4 = OP_SUCCESS, res6 = OP_SUCCESS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 确保我们至少有一个目标 */</span></span><br><span class="line">  <span class="keyword">if</span> (Targets.size() &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> OP_FAILURE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将目标分为两组：IPv4和IPv6 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; Targets.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Targets[i]-&gt;af() == AF_INET6)</span><br><span class="line">          ip6_targets.push_back(Targets[i]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          ip4_targets.push_back(Targets[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* IPv4操作系统检测 */</span></span><br><span class="line">  <span class="keyword">if</span> (ip4_targets.size() &gt; <span class="number">0</span>)</span><br><span class="line">      res4 = this-&gt;os_scan_ipv4(ip4_targets);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* IPv6操作系统检测 */</span></span><br><span class="line">  <span class="keyword">if</span> (ip6_targets.size() &gt; <span class="number">0</span>)</span><br><span class="line">      res6 = this-&gt;os_scan_ipv6(ip6_targets);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果两次扫描都成功，返回OK */</span></span><br><span class="line">  <span class="keyword">if</span> (res4 == OP_SUCCESS &amp;&amp; res6 == OP_SUCCESS)</span><br><span class="line">    <span class="keyword">return</span> OP_SUCCESS;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> OP_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的实现方法这里不再跟进</p>
<p>继续看主函数中的<code>traceroute()</code>：路由追踪</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">traceroute</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt; &amp;Targets)</span> &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt; direct, remote;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt;::iterator target_iter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将直接连接的目标与远程目标分开。 */</span></span><br><span class="line">  <span class="keyword">for</span> (target_iter = Targets.begin();</span><br><span class="line">       target_iter != Targets.end();</span><br><span class="line">       target_iter++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((*target_iter)-&gt;ifType() == devt_loopback)</span><br><span class="line">      ; <span class="comment">/* Ignore */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((*target_iter)-&gt;directlyConnected())</span><br><span class="line">      direct.push_back(*target_iter);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      remote.push_back(*target_iter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  traceroute_direct(direct);    <span class="comment">//执行关于直接连接目标和远程目标的跟踪路由操作</span></span><br><span class="line">  traceroute_remote(remote);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进这里的<code>traceroute_direct(direct);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">traceroute_direct</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt; targets)</span> &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (it = targets.begin(); it != targets.end(); it++) &#123;</span><br><span class="line">    TracerouteHop hop;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *hostname;</span><br><span class="line">    <span class="type">size_t</span> sslen;</span><br><span class="line"></span><br><span class="line">    sslen = <span class="keyword">sizeof</span>(hop.tag);</span><br><span class="line">    (*it)-&gt;TargetSockAddr(&amp;hop.tag, &amp;sslen);  <span class="comment">//获取目标的套接字地址</span></span><br><span class="line">    hop.timedout = <span class="literal">false</span>; </span><br><span class="line">    hop.rtt = (*it)-&gt;to.srtt / <span class="number">1000.0</span>;</span><br><span class="line">    hostname = (*it)-&gt;HostName();  <span class="comment">//获取目标的主机名</span></span><br><span class="line">    <span class="keyword">if</span> (hostname != <span class="literal">NULL</span> &amp;&amp; hostname[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">      hop.name = hostname;</span><br><span class="line">    hop.addr = hop.tag;</span><br><span class="line">    hop.ttl = <span class="number">1</span>;</span><br><span class="line">    (*it)-&gt;traceroute_hops.push_front(hop);  <span class="comment">//这个链表用于存储跟踪路由的每一跳信息</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看<code>traceroute_remote(remote);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">traceroute_remote</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt; targets)</span> &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt;::iterator target_iter;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">while</span> (!global_state.active_hosts.empty()) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    global_state.send_new_probes(); <span class="comment">//发送新的探测请求</span></span><br><span class="line">    now = get_now();  <span class="comment">//获取当前时间</span></span><br><span class="line">    timeout = TIMEVAL_SUBTRACT(global_state.next_send_time, now); <span class="comment">//计算超时时间</span></span><br><span class="line">    global_state.read_replies(timeout);</span><br><span class="line">    global_state.cull_timeouts();  <span class="comment">//剔除超时的探测</span></span><br><span class="line">    global_state.remove_finished_hosts(); <span class="comment">//移除已完成的主机</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (keyWasPressed())</span><br><span class="line">      SPM.printStats(global_state.completion_fraction(), <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SPM.endTask(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!o.noresolve)</span><br><span class="line">    global_state.resolve_hops();  <span class="comment">//将跟踪路由的跳数信息转移到全局状态对象中</span></span><br><span class="line">  <span class="comment">/* 这会将 hop 放入 global_state 已知的目标中。 */</span></span><br><span class="line">  global_state.transfer_hops();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将 initial_ttl 更新为该主机组中看到的最大距离，作为对下一个的估计。 */</span></span><br><span class="line">  initial_ttl = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (target_iter = targets.begin();</span><br><span class="line">       target_iter != targets.end();</span><br><span class="line">       target_iter++) &#123;</span><br><span class="line">    initial_ttl = MAX(initial_ttl, (*target_iter)-&gt;traceroute_hops.size()); <span class="comment">//获取每个目标的跟踪路由跳数，并将其与initial_ttl进行比较，取较大的值</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hop_cache_size() &gt; MAX_HOP_CACHE_SIZE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o.debugging) &#123;</span><br><span class="line">      log_write(LOG_STDOUT, <span class="string">&quot;Clearing hop cache that has grown to %d\n&quot;</span>,</span><br><span class="line">        hop_cache_size());</span><br><span class="line">    &#125;</span><br><span class="line">    traceroute_hop_cache_clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>回到主函数，看<code>script_scan(Targets, SCRIPT_SCAN);</code>：脚本扫描</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">script_scan</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Target *&gt; &amp;targets, stype scantype)</span></span><br><span class="line">&#123;</span><br><span class="line">  o.current_scantype = scantype;</span><br><span class="line"></span><br><span class="line">  assert(L_NSE != <span class="literal">NULL</span>);</span><br><span class="line">  lua_settop(L_NSE, <span class="number">0</span>); <span class="comment">/* clear the stack */</span></span><br><span class="line"></span><br><span class="line">  lua_pushcfunction(L_NSE, nseU_traceback);</span><br><span class="line">  lua_pushcfunction(L_NSE, run_main);</span><br><span class="line">  lua_pushlightuserdata(L_NSE, &amp;targets);</span><br><span class="line">  <span class="keyword">if</span> (lua_pcall(L_NSE, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    error(<span class="string">&quot;%s: Script Engine Scan Aborted.\nAn error was thrown by the &quot;</span></span><br><span class="line">          <span class="string">&quot;engine: %s&quot;</span>, SCRIPT_ENGINE, lua_tostring(L_NSE, <span class="number">-1</span>));</span><br><span class="line">  lua_settop(L_NSE, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数使用Lua脚本引擎来执行脚本，并将<code>targets</code>作为参数传递给Lua脚本。这样可以灵活地使用脚本来定义和执行各种类型的扫描任务。</p>
<p>对于脚本扫描的理解，建议自己百度（手动doge），这里贴一篇：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26618074">Nmap脚本使用指南</a></p>
<p>到这里，nmap源码的主要部分已经大致浏览完毕，再次声明，本文<strong>旨在浏览关键代码，并无深究其中代码细节</strong>，希望通过对源码的阅读了解部分关键技术</p>
<p>（注意，上面的代码与源码有部分删减，汉化源码中的部分注释。本系列将持续更新，敬请关注）</p>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>-<a class="flink" target="_blank" rel="noopener" href="https://github.com/sanjinhub/hexo-theme-geek">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="FqiyUqbg7McKN2eG0MCewupf">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>